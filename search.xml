<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux入门（五）Linux文件与目录管理]]></title>
    <url>%2F2018%2F05%2F19%2FLinux_5%2F</url>
    <content type="text"><![CDATA[绝对路径和相对路径在Linux中什么是一个文件的路径呢，说白了就是这个文件存在的地方，例如/root/.ssh/authorized_keys这就是一个文件的路径。如果你告诉系统这个文件的路径，那么系统就可以找到这个文件。在Linux的世界中，存在着绝对路径和相对路径。 绝对路径路径的写法一定由根目录”/”写起，例如/usr/local/mysql 这就是绝对路径。 相对路径路径的写法不是由根目录”/”写起，例如，首先用户进入到/ ，然后再进入到home，命令为 cd /home，然后 cd test，此时用户所在的路径为/home/test。第一个cd命令后跟 /home，第二个cd命令后跟test，并没有斜杠，这个test是相对于/home 目录来讲的，所以叫做相对路径。 一些常用的指令pwd 这个命令打印出当前所在目录123[root@localhost ~]# pwd/root[root@localhost ~]# cd 进入到某一个目录1234[root@localhost ~]# cd /usr/local[root@localhost local]# pwd/usr/local[root@localhost local]# ./ 指的是当前目录 ../ 指的是当前目录的上一级目录。12345678910[root@localhost local]# cd /usr/local/lib/[root@localhost lib]# pwd/usr/local/lib[root@localhost lib]# cd ./[root@localhost lib]# pwd/usr/local/lib[root@localhost lib]# cd ../[root@localhost local]# pwd/usr/local[root@localhost local]# 首先进入到/usr/local/lib/目录下，然后再进入./其实还是进入到当前目录下，用pwd查看当前目录，并没有发生变化，然后再进入../ 则是进入到了/usr/local/目录下，即/usr/local/lib目录的上一级目录。 mkdir 创建一个目录。mkdir其实就是make directory的缩写。其语法为mkdir [-mp] [目录名称]，其中-m , –p 为其选项，-m：这个参数用来指定要创建目录的权限，该参数不常用，所以不做重点解释。-p：这个参数很管用的，先来做个试验，就会一目了然了。12345[root@localhost local]# mkdir /tmp/test/123mkdir: 无法创建目录&quot;/tmp/test/123&quot;: 没有那个文件或目录[root@localhost local]# ls /tmp/test/ls: 无法访问/tmp/test/: 没有那个文件或目录[root@localhost local]# 当我们想创建/tmp/test/123目录，可是提示不能创建，原因是/tmp/test目录不存在，你会说，这个Linux怎么这傻，/tmp/test目录不存在就自动创建不就OK了嘛，的确Linux确实很傻，如果它发现要创建的目录的上一级目录不存在就会报错。然后Linux也为我们想好了解决办法，即-p参数。1234[root@localhost local]# mkdir -p /tmp/test/123[root@localhost local]# ls /tmp/test/123[root@localhost local]# -p 它的作用就是递归创建目录，即使上级目录不存在。还有一种情况就是如果你想要创建的目录存在的话，会提示报错，然后你加上-p参数后，就不会报错，如下所示：1234[root@localhost local]# mkdir /tmp/test/123mkdir: 无法创建目录&quot;/tmp/test/123&quot;: 文件已存在[root@localhost local]# mkdir -p /tmp/test/123[root@localhost local]# rmdir 删除一个目录。 12345[root@localhost local]# ls /tmp/test123[root@localhost local]# rmdir /tmp/test/123[root@localhost local]# ls /tmp/test[root@localhost local]# rmdir,其实是rmove directory缩写，其只有一个选项-p 类似与mkdir命令，这个参数的作用是将上级目录一起删除。举个例子吧，新建目录mkdir -p d1/d2/d3 ，rmdir -p d1/d2/d3相当于是删除了d1,d1/d2, d1/d2/d3。 rm 删除目录或者文件。rmdir只能删除目录但不能删除文件，要想删除一个文件，则要用rm命令了。rm同样也有很多选项。可以通过man rm来获得详细帮助信息。在这里只列举较常用的几个选项。 -f 强制的意思，如果不加这个选项，当删除一个不存在的文件时会报错。123456[root@localhost local]# ls /tmp/111ls: 无法访问/tmp/111: 没有那个文件或目录[root@localhost local]# /bin/rm /tmp/111rm: 无法删除&quot;/tmp/111&quot;: 没有那个文件或目录[root@localhost local]# /bin/rm -f /tmp/111[root@localhost local]# 当用户用rm删除一个文件时会提示用户是否真的删除。123[root@localhost ~]# rm /root/anaconda-ks.cfgrm：是否删除普通空文件 &quot;/root/anaconda-ks.cfg&quot;？n[root@localhost ~]# 如果删除，输入y, 否则输入n -r 当删除目录时，加该选项，如果不加这个选项会报错。rm是可以删除不为空的目录的。123456789[root@localhost ~]# mkdir /tmp/test/123/[root@localhost ~]# ls /tmp/test/123[root@localhost ~]# rm /tmp/test/123rm: 无法删除&quot;/tmp/test/123&quot;: 是一个目录[root@localhost ~]# rm -r /tmp/test/123rm：是否删除目录 &quot;/tmp/test/123&quot;？y[root@localhost ~]# ls /tmp/test/[root@localhost ~]# 12345678910[root@localhost ~]# mkdir /tmp/test/123/[root@localhost ~]# ls /tmp/test/123[root@localhost ~]# rm -r /tmp/test/rm：是否进入目录&quot;/tmp/test/&quot;? yrm：是否删除目录 &quot;/tmp/test/123&quot;？yrm：是否删除目录 &quot;/tmp/test/&quot;？y[root@localhost ~]# ls /tmp/test/ls: 无法访问/tmp/test/: 没有那个文件或目录[root@localhost ~]# 关于rm，使用最多便是-rf两个选项合用了。不管删除文件还是目录都可以。但是方便的同时也要多注意，万一你的手太快后边跟了/那样就会把你的系统文件全部删除的，切记切记。123456789101112[root@localhost ~]# mkdir -p /d1/d2/d3[root@localhost ~]# rm -r /d1rm：是否进入目录&quot;/d1&quot;? yrm：是否进入目录&quot;/d1/d2&quot;? yrm：是否删除目录 &quot;/d1/d2/d3&quot;？yrm：是否删除目录 &quot;/d1/d2&quot;？yrm：是否删除目录 &quot;/d1&quot;？y[root@localhost ~]# mkdir -p /d1/d2/d3[root@localhost ~]# rm -rf /d1[root@localhost ~]# ls /d1ls: 无法访问/d1: 没有那个文件或目录[root@localhost ~]# which 用来查找一个命令的绝对路径。1234[root@localhost ~]# which rmalias rm=&apos;rm -i&apos; /usr/bin/rm[root@localhost ~]# alias 用来设置指令的别名。语法：alias[别名]=[指令名称]，例如 alias rm=’rm -i’ ，即当我们使用rm命令时，实际上是使用的是rm –i ，而用绝对路径的/user/bin/rm 则不会被alias，该命令在以后会详细介绍。 ls 在前面的命令中多次用到它。它的作用就是查看某个目录或者某个文件，是list的简写。ls 后可以跟一个目录，也可以跟一个文件。以下是ls的选项，在这里并没有完全列出，只是列出了平时使用最多的选项。其他选项，你可以自行通过man ls查询。 -a 全部的档案都列出，包括隐藏的。linux文件系统中同样也有隐藏文件。这些隐藏文件的文件名是以.开头的。例如.test, /root/.123, /root/.ssh 等等，隐藏文件可以是目录也可以是普通文件。 -l 详细列出文件的属性信息，包括大小、创建日期、所属主所属组等等。ll这个命令等同于ls –l 。1234[root@localhost ~]# which llalias ll=&apos;ls -l --color=auto&apos; /usr/bin/ls[root@localhost ~]# –color=never/always/auto never即不要显示颜色，always即总显示颜色，auto是由系统自行判断。 -d 后边跟目录，如果不加这个选项则列出目录下的文件，加上后只列车目录本身。12345[root@localhost ~]# ls -d /root//root/[root@localhost ~]# ls /rootanaconda-ks.cfg[root@localhost ~]# cp copy的简写，即拷贝。格式为cp [选项] [来源文件] [目的文件]，例如我想把test1拷贝成test2 输入以下命令即可：1cp test1 test2 以下介绍几个常用的选项 -d 这里涉及到一个“连接”的概念。连接分为软连接和硬连接。这在以后会详细解释，现在只需要明白这里的软连接跟Windows中的快捷方式类似即可。如果不加这个-d 则拷贝软连接时会把软连接的目标文件拷贝过去，而加上后，其实只是拷贝了一个连接文件（即快捷方式）。12345678910111213141516171819202122[root@localhost ~]# mkdir /tmp/test/[root@localhost ~]# cd /tmp/test/[root@localhost test]# touch test[root@localhost test]# ln -s test test1[root@localhost test]# ls -l总用量 0-rw-r--r--. 1 root root 0 5月 20 12:48 testlrwxrwxrwx. 1 root root 4 5月 20 12:49 test1 -&gt; test[root@localhost test]# cp test1 test2[root@localhost test]# ls -l总用量 0-rw-r--r--. 1 root root 0 5月 20 12:48 testlrwxrwxrwx. 1 root root 4 5月 20 12:49 test1 -&gt; test-rw-r--r--. 1 root root 0 5月 20 12:50 test2[root@localhost test]# cp -d test1 test3[root@localhost test]# ls -l总用量 0-rw-r--r--. 1 root root 0 5月 20 12:48 testlrwxrwxrwx. 1 root root 4 5月 20 12:49 test1 -&gt; test-rw-r--r--. 1 root root 0 5月 20 12:50 test2lrwxrwxrwx. 1 root root 4 5月 20 12:50 test3 -&gt; test[root@localhost test]# 上面的ln命令即为建立连接的，以后再做详细解释。 -r 如果你要拷贝一个目录，必须要加-r选项，否则你是拷贝不了目录的。1234567891011[root@localhost test]# mkdir 123[root@localhost test]# ls123 test test1 test2 test3[root@localhost test]# cp 123 111cp: 略过目录&quot;123&quot;[root@localhost test]# ls123 test test1 test2 test3[root@localhost test]# cp -r 123 111[root@localhost test]# ls111 123 test test1 test2 test3[root@localhost test]# -i 如果遇到一个存在的文件，会问是否覆盖。在Redhat/CentOS系统中，我们使用的cp其实是cp –i1234[root@localhost test]# which cpalias cp=&apos;cp -i&apos; /usr/bin/cp[root@localhost test]# 12345678910111213141516[root@localhost test]# cd 123[root@localhost 123]# ls[root@localhost 123]# touch 111[root@localhost 123]# touch 222[root@localhost 123]# /usr/bin/cp -i 111 222/usr/bin/cp：是否覆盖&quot;222&quot;？ n[root@localhost 123]# echo &apos;abc&apos; &gt;111[root@localhost 123]# echo &apos;def&apos; &gt;222[root@localhost 123]# cat 111abc[root@localhost 123]# cat 222def[root@localhost 123]# /usr/bin/cp 111 222[root@localhost 123]# cat 222abc[root@localhost 123]# 上面，touch 命令，看字面意思就是摸一下，没错，如果有这个文件，则会改变文件的访问时间，如果没有这个文件就会创建这个文件。前面说过echo，其实就是打印，在这里所echo的内容”abc”和“def”并没有显示在屏幕上，而是分别写进了文件111和222, 其写入作用的就是这个大于号”&gt;” 在Linux中这叫做重定向，即把前面产生的输出写入到后面的文件中。这在以后会做详细介绍，这里需要明白它的含义即可。而cat命令则是读一个文件，并把读出的内容打印到当前屏幕上。 -u 该选项仅当目标文件存在时才会生效，如果源文件比目标文件新才会拷贝，否则不做任何动作。 mv 移动的意思，是move的简写。格式为mv [选项] [源文件] [目标文件]，下面介绍几个常用的选项。 -i 和cp的-i 一样，当目标文件存在时会问用户是否要覆盖。在Redhat/CentOS系统中，我们使用的mv其实是mv –i -u 和上边cp命令的-u选项一个作用，当目标文件存在时才会生效，如果源文件比目标文件新才会移动，否则不做任何动作。 该命令有以下中情况 目标文件是目录，而且目标文件不存在； 目标文件是目录，而且目标文件存在； 目标文件不是目录不存在； 目标文件不是目录存在； 目标文件是目录，存在和不存在，移动的结果是不一样的，如果存在，则会把源文件移动到目标文件目录中。不存在的话移动完后，目标文件是一个文件。1234567891011121314151617181920212223[root@localhost 123]# cd ../111[root@localhost 111]# ls[root@localhost 111]# mkdir aa bb[root@localhost 111]# lsaa bb[root@localhost 111]# mv aa cc[root@localhost 111]# lsbb cc[root@localhost 111]# mv cc bb[root@localhost 111]# lsbb[root@localhost 111]# ls bbcc[root@localhost 111]# touch dd[root@localhost 111]# lsbb dd[root@localhost 111]# mv dd ee[root@localhost 111]# lsbb ee[root@localhost 111]# mv ee bb[root@localhost 111]# ls bbcc ee[root@localhost 111]# Windows下的重命名，在linux下用mv就可以搞定。cat 比较常用的一个命令，即查看一个文件的内容并显示在屏幕上。 -n 查看文件时，把行号也显示到屏幕上。123456789[root@localhost 111]# echo &apos;123123 &apos; &gt;bb/ee[root@localhost 111]# echo &apos;456456 &apos; &gt;&gt;bb/ee[root@localhost 111]# cat bb/ee123123456456[root@localhost 111]# cat -n bb/ee 1 123123 2 456456[root@localhost 111]# 上面出现了一个”&gt;&gt;”，这个符号跟前面介绍的”&gt;”的作用都是重定向，即把前面输出的东西输入到后边的文件中，只是”&gt;&gt;”是追加的意思，而用”&gt;”，如果文件中有内容则会删除文件中内容，而”&gt;&gt;”则不会。 -A 显示所有东西出来，包括特殊字符1234[root@localhost 111]# cat -A bb/ee123123 $456456 $[root@localhost 111]# tac 其实是cat的反写，同样的功能也是反向打印文件的内容到屏幕上。1234[root@localhost 111]# tac bb/ee456456 123123 [root@localhost 111]# more 也是用来查看一个文件的内容。当文件内容太多，一屏幕不能占下，而你用cat肯定是看不前面的内容的，那么使用more就可以解决这个问题了。当看完一屏后按空格键继续看下一屏。但看完所有内容后就会退出。如果想提前退出，只需按q键即可。 less 作用跟more一样，但比more好在可以上翻，下翻。空格键同样可以翻页，而按”j”键可以向下移动（按一下就向下移动一行），按”k”键向上移动。在使用more和less查看某个文件时，你可以按一下”/” 键，然后输入一个word回车，这样就可以查找这个word了。如果是多个该word可以按”n”键显示下一个。另外你也可以不按”/”而是按”?”后边同样跟word来搜索这个word，唯一不同的是，”/”是在当前行向下搜索，而”?”是在当前行向上搜索。 head head后直接跟文件名，则显示文件的前十行。如果加 –n 选项则显示文件前n行。123456789101112131415161718[root@localhost 111]# head /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin[root@localhost 111]# head -n 5 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin[root@localhost 111]# tail 和head一样，后面直接跟文件名，则显示文件最后十行。如果加-n 选项则显示文件最后n行。123456789101112131415[root@localhost 111]# tail /etc/passwdoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:999:998:User for polkitd:/:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinjgh:x:1000:1000:jgh:/home/jgh:/bin/bash[root@localhost 111]# tail -n 2 /etc/passwdpostfix:x:89:89::/var/spool/postfix:/sbin/nologinjgh:x:1000:1000:jgh:/home/jgh:/bin/bash[root@localhost 111]# -f 动态显示文件的最后十行，如果文件是不断增加的，则用-f 选项。如：tail -f /var/log/messages 环境变量PATH上边提到了alias，也提到了绝对路径的/user/bin/rm ，然后你意识到没有，为什么我们输入很多命令时是直接打出了命令，而没有去使用这些命令的绝对路径？这是因为环境变量PATH在起作用了。请输入 echo $PATH，这里的echo其实就是打印的意思，而PATH前面的$表示后面接的是变量。12345[root@localhost ~]# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin[root@localhost ~]# echo hellohello[root@localhost ~]# 因为/usr/bin 在PATH的设定中，所以自然就可以找到ls了。如果你将ls移动到/root底下的话，然后你自己本身也在/root底下，但是当你执行ls的时候，他就是不理你？怎么办？这是因为PATH没有/root 这个目录，而你又将ls移动到/root底下了，自然系统就找不到可执行文件了，因此就会告诉你， command not found！那么该怎么克服这种问题呢？ 有两个方法，一种方法是直接将/root的路径加入PATH当中！可以使用以下命令： 1PATH=”$PATH”:/root 另一种方式则是使用完整档名，亦即直接使用相对或绝对路径来执行，例如：12/root/ls./ls 文件的所属主以及所属组一个Linux目录或者文件，都会有一个所属主和所属组。所属主，即文件的拥有者，而所属组，即该文件所属主所在的一个组。Linux这样设置文件属性的目的是为了文件的安全。例如，test文件的所属主是user0 而test1文件的所属主是user1，那么user1是不能查看test文件的，相应的user0也不能查看test1文件。然后有这样一个应用，我想创建一个文件同时让user0和user1来查看怎么办呢？ 这时“所属组”就派上用场了。即，创建一个群组users，让user0和user1同属于users组，然后建立一个文件test2，且其所属组为users，那么user0和user1都可以访问test2文件。 Linux文件属性不仅规定了所属主和所属组，还规定了所属主（user）、所属组(group)以及其他用户（others）对该文件的权限。你可以通过ls -l 来查看这些属性。123456789[root@localhost ~]# cd /tmp/test/[root@localhost test]# ls -l总用量 0drwxr-xr-x. 3 root root 16 5月 20 13:39 111drwxr-xr-x. 2 root root 28 5月 20 13:23 123-rw-r--r--. 1 root root 0 5月 20 12:48 testlrwxrwxrwx. 1 root root 4 5月 20 12:49 test1 -&gt; test-rw-r--r--. 1 root root 0 5月 20 13:16 test2lrwxrwxrwx. 1 root root 4 5月 20 12:50 test3 -&gt; test Linux文件属性上面用ls –l查看当前目录下的文件时，共显示了9列内容（用空格划分列），都代表了什么含义呢？ 第1列，包含的东西有该文件类型和所属主、所属组以及其他用户对该文件的权限。第一列共10位。其中第一位用来描述该文件的类型。我们看到的类型有”d”, “-“，”l” ，其实除了这两种外还有“b”, “c”,”s”等。 “d” 表示该文件为目录； “-“ 表示该文件为普通文件； “l” 表示该文件为连接文件（Linux file），上边提到的软连接即为该类型； “b” 表示该文件为块设备文件，比如磁盘分区 “c” 表示该文件为串行端口设备，例如键盘、鼠标。 “s” 表示该文件为套接字文件（socket），用于进程间通信。 后边的9位，每三个为一组。均为rwx三个参数的组合。其中r代表可读，w代表可写，x代表可执行。前三位为所属主（user）的权限，中间三位为所属组（group）的权限，最后三位为其他非本群组（others）的权限。下面拿一个具体的例子来述说一下。 一个文件的属性为-rwxr-xr– ，它代表的意思是，该文件为普通文件，文件拥有者可读可写可执行，文件所属组对其可读不可写可执行，其他用户对其只可读。 对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个目录必须要有x权限才能打开并查看该目录。例如一个目录的属性为drwxr–r– 其所属主为root，那么除了root外的其他用户是不能打开这个目录的。 第2列，表示为连接占用的节点（inode），若为目录时，通常与该目录地下还有多少目录有关系，关于连接（link）在以后详细介绍。 第3列，表示该文件的所属主。 第4列，表示该文件的所属组。 第5列，表示该文件的大小。 第6列、第7列和第8列为该文件的创建日期或者最近的修改日期，分别为月份日期以及时间。 第9列，文件名。如果前面有一个. 则表示该文件为隐藏文件。 更改文件的权限更改文件的权限，也就是更改所属主、所属组以及他们对应的读写执行权限。 更改所属组chgrp chgrp其实就是change group的缩写。 语法：chgrp [组名] [文件名]12345678910[root@localhost ~]# cd /tmp/test[root@localhost test]# ls111 123 test test1 test2 test3[root@localhost test]# groupadd testgroup[root@localhost test]# ls -l test-rw-r--r--. 1 root root 0 5月 20 12:48 test[root@localhost test]# chgrp testgroup test[root@localhost test]# ls -l test-rw-r--r--. 1 root testgroup 0 5月 20 12:48 test[root@localhost test]# 这里用到了groupadd命令，其含义即增加一个用户组。该命令在以后会做详细介绍，现在只需要知道它是用来增加用户组的即可。 更改文件的所属主chown chown其实就是change owner的缩写。语法： chown [ -R ] 账户名 文件名 chown [ -R ] 账户名：组名 文件名 这里的-R选项只作用于目录，作用是级联更改，即不仅更改当前目录，连目录里的目录或者文件全部更改。1234567891011121314151617181920212223[root@localhost test]# useradd user1[root@localhost test]# ls -ld 111drwxr-xr-x. 3 root root 16 5月 20 13:39 111[root@localhost test]# touch 111/test2[root@localhost test]# ls -l 111总用量 0drwxr-xr-x. 3 root root 26 5月 20 13:45 bb-rw-r--r--. 1 root root 0 5月 20 17:15 test2[root@localhost test]# chown user1 111[root@localhost test]# ls -ld 111drwxr-xr-x. 3 user1 root 29 5月 20 17:15 111[root@localhost test]# ls -l 111总用量 0drwxr-xr-x. 3 root root 26 5月 20 13:45 bb-rw-r--r--. 1 root root 0 5月 20 17:15 test2[root@localhost test]# chown -R user1:testgroup 111[root@localhost test]# ls -ld 111drwxr-xr-x. 3 user1 testgroup 29 5月 20 17:15 111[root@localhost test]# ls -l 111总用量 0drwxr-xr-x. 3 user1 testgroup 26 5月 20 13:45 bb-rw-r--r--. 1 user1 testgroup 0 5月 20 17:15 test2[root@localhost test]# useradd是增加一个账户，以后会详细介绍。在111目录下创建一个普通文件test2，因为是以root的身份创建的目录和文件，所以所属主以及所属组都是root。chown user1 111这使111的目录所属主由root变为了user1 ，然后111目录下的test2文件所属主以及所属组还是root。接着chown –R user1:testgroup 111这样把111连同111目录下的test2 的所属主以及所属组都改变了。 改变用户对文件的读写执行权限chmod 语法： chmod [-R] xyz 文件名 （这里的xyz，表示数字） -R 选项作用同chown，级联更改。 在Linux中为了方便更改这些权限，Linux使用数字去代替rwx，具体规则为r:4 w:2 x:1 -:0 举个例子，-rwxrwx—用数字表示就是770，具体是这样来的： rwx = 4+2+1=7; rwx= 4+2+1=7; — = 0+0+0=0 值得提一下的是，在Linux系统中，默认一个目录的权限为755，而一个文件的默认权限为644。12345678910111213141516171819[root@localhost test]# ls -dl 111drwxr-xr-x. 3 user1 testgroup 29 5月 20 17:15 111[root@localhost test]# ls -l 111总用量 0drwxr-xr-x. 3 user1 testgroup 26 5月 20 13:45 bb-rw-r--r--. 1 user1 testgroup 0 5月 20 17:15 test2[root@localhost test]# chmod 750 111[root@localhost test]# ls -ld 111drwxr-x---. 3 user1 testgroup 29 5月 20 17:15 111[root@localhost test]# ls -l 111/test2-rw-r--r--. 1 user1 testgroup 0 5月 20 17:15 111/test2[root@localhost test]# chmod -R 700 111[root@localhost test]# ls -ld 111drwx------. 3 user1 testgroup 29 5月 20 17:15 111[root@localhost test]# ls -l 111总用量 0drwx------. 3 user1 testgroup 26 5月 20 13:45 bb-rwx------. 1 user1 testgroup 0 5月 20 17:15 test2[root@localhost test]# 如果你创建了一个目录，而该目录不想让其他人看到内容，则只需设置成 rwxr—– (740) 即可。 chmod还支持使用rwx的方式来设置权限。从之前的介绍中我们可以发现，基本上就九个属性分别是(1)user (2)group (3)others 三群啦。那么我们就可以藉由 u, g, o 来代表三群的属性！此外， a则代表all, 亦即全部的三群。那么读写的属性就可以写成了 r, w, x！也就是可以使用底下的方式来看： 现在我想把一个文件设置成这样的权限 rwxr-xr-x (755)，使用这种方式改变权限的命令为:1234[root@localhost test]# chmod u=rwx,go=rx 111/test2[root@localhost test]# ls -l 111/test2-rwxr-xr-x. 1 user1 testgroup 0 5月 20 17:15 111/test2[root@localhost test]# 另外还可以针对u, g, o, a增加或者减少某个权限（读，写，执行），例如：12345678910[root@localhost test]# chmod u-x 111/test2[root@localhost test]# ls -l 111/test2-rw-r-xr-x. 1 user1 testgroup 0 5月 20 17:15 111/test2[root@localhost test]# chmod a-x 111/test2[root@localhost test]# ls -l 111/test2-rw-r--r--. 1 user1 testgroup 0 5月 20 17:15 111/test2[root@localhost test]# chmod u+x 111/test2[root@localhost test]# ls -l 111/test2-rwxr--r--. 1 user1 testgroup 0 5月 20 17:15 111/test2[root@localhost test]# umask 上边也提到了默认情况下，目录权限值为755，普通文件权限值为644。那么这个值是由谁规定呢？追究其原因就涉及到了umask。 umask语法： umask xxx （这里的xxx代表三个数字） 查看umask值只要输入umask然后回车。 umask预设是0022，其代表什么含义？先看一下下面的规则： 1）若用户建立为普通文件，则预设“没有可执行权限”，只有rw两个权限。最大为666（-rw-rw-rw-） 2）若用户建立为目录，则预设所有权限均开放，即777（drwxrwxrwx） umask数值代表的含义为，上边两条规则中的默认值（文件为666，目录为777）需要减掉的权限。所以目录的权限为(rwxrwxrwx) – (—-w–w-) = (rwxr-xr-x)，普通文件的权限为(rw-rw-rw-) – (—-w–w-) = (rw-r–r–)。umask的值是可以自定义的，比如设定umask为002，你再创建目录或者文件时，默认权限分别为(rwxrwxrwx) – (——-w-) = (rwxrwxr-x)和(rw-rw-rw-) – (——-w-) = (rw-rw-r–)。12345678910[root@localhost test]# umask0022[root@localhost test]# umask 002[root@localhost test]# mkdir test4[root@localhost test]# ls -ld test4drwxrwxr-x. 2 root root 6 5月 20 20:55 test4[root@localhost test]# touch test5[root@localhost test]# ls -l test5-rw-rw-r--. 1 root root 0 5月 20 20:56 test5[root@localhost test]# umask可以在/etc/bashrc里面更改，预设情况下，root的umask为022，而一般使用者则为002，因为可写的权限非常重要，因此预设会去掉写权限。 修改文件的特殊属性chattr chattr其实就是change attribute的缩写。 语法： chattr [+-=][ASaci] 文件或者目录名 +-= ：分别为增加、减少、设定 A：增加该属性后，文件或目录的atime将不可被修改； S：增加该属性后，会将数据同步写入磁盘中； a：增加该属性后，只能追加不能删除，非root用户不能设定该属性； c：自动压缩该文件，读取时会自动解压； i：增加后，使文件不能被删除、重命名、设定连接、写入、新增数据；12345678[root@localhost test]# chattr +i test4[root@localhost test]# touch test4/123touch: 无法创建&quot;test4/123&quot;: 权限不够[root@localhost test]# chattr -i test4[root@localhost test]# touch test4/123[root@localhost test]# ls test4123[root@localhost test]# 增加i属性后不能在该目录中建立文件。123456789101112131415161718[root@localhost test]# touch test4/456[root@localhost test]# ls test4123 456[root@localhost test]# chattr +a test4[root@localhost test]# rm test4/456rm：是否删除普通空文件 &quot;test4/456&quot;？yrm: 无法删除&quot;test4/456&quot;: 不允许的操作[root@localhost test]# touch test4/789[root@localhost test]# ls test4123 456 789[root@localhost test]# chattr -a test4[root@localhost test]# ls test4123 456 789[root@localhost test]# rm test4/456rm：是否删除普通空文件 &quot;test4/456&quot;？y[root@localhost test]# ls test4123 789[root@localhost test]# 增加a属性后，只能追加不能删除。 列出文件/目录的特殊属性lsattr 语法： lsattr [-aR] [文件/目录名] -a：类似与ls的-a选项，即连同隐藏文件一同列出； -R：连同子目录的数据一同列出1234567891011121314151617181920[root@localhost test]# lsattr -a test4---------------- test4/.---------------- test4/..---------------- test4/123---------------- test4/789[root@localhost test]# mkdir test4/test[root@localhost test]# touch test4/test/aa[root@localhost test]# lsattr -R test4---------------- test4/123---------------- test4/789---------------- test4/testtest4/test:---------------- test4/test/aa[root@localhost test]# lsattr test4---------------- test4/123---------------- test4/789---------------- test4/test[root@localhost test]# 在Linux下搜索一个文件在Windows下有一个搜索工具，可以让我们很快的找到一个文件，这是很有用的。然而在linux下搜索功能更加强大。 which 用来查找可执行文件的绝对路径。 在前面已经多次用到该命令，需要注意的一点是，which只能用来查找PATH环境变量中出现的路径下的可执行文件。这个命令用的也是蛮多的，有时候我们不知道某个命令的绝对路径，which一下很容易就知道了。123456[root@localhost test]# which lsalias ls=&apos;ls --color=auto&apos; /usr/bin/ls[root@localhost test]# which cd/usr/bin/cd[root@localhost test]# 当查找的文件在PATH变量中并没有时，就会报错。 whereis 通过预先生成的一个文件列表库去查找跟给出的文件名相关的文件。 语法： whereis [-bmsu] [文件名称] -b：只找binary 文件 -m：只找在说明文件manual路径下的文件 -s：只找source来源文件 -u：没有说明档的文件123456789[root@localhost test]# whereis passwdpasswd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz[root@localhost test]# where -b passwd-bash: where: 未找到命令[root@localhost test]# whereis -b passwdpasswd: /usr/bin/passwd /etc/passwd[root@localhost test]# whereis -m passwdpasswd: /usr/share/man/man1/passwd.1.gz[root@localhost test]# locate 类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里。后边直接跟文件名。如果你的Linux没有这个命令，请安装软件包mlocate，这个软件包在你的系统安装盘里，后缀名是RPM，随后介绍的find命令会告诉你如何查找这个包。如果你装的CentOS你可以使用这个命令来安装 yum install –y mlocate 。 前提是你的CentOS能连互联网。至于yum这个命令如何使用，到后续章节你自然会明白。如果你刚装上这个命令，初次使用会报错。123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost test]# locate passwd-bash: locate: 未找到命令[root@localhost test]# yum install –y mlocate已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.sohu.com * extras: mirrors.163.com * updates: mirrors.163.com正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 mlocate.x86_64.0.0.26-8.el7 将被 安装--&gt; 解决依赖关系完成依赖关系解决======================================================================================================================================================================= Package 架构 版本 源 大小=======================================================================================================================================================================正在安装: mlocate x86_64 0.26-8.el7 base 113 k事务概要=======================================================================================================================================================================安装 1 软件包总下载量：113 k安装大小：379 kIs this ok [y/d/N]: yDownloading packages:mlocate-0.26-8.el7.x86_64.rpm | 113 kB 00:00:01 Running transaction checkRunning transaction testTransaction test succeededRunning transaction 正在安装 : mlocate-0.26-8.el7.x86_64 1/1 验证中 : mlocate-0.26-8.el7.x86_64 1/1 已安装: mlocate.x86_64 0:0.26-8.el7 完毕！[root@localhost test]# 12[root@localhost test]# locate passwdlocate: 无法执行 stat () `/var/lib/mlocate/mlocate.db&apos;: 没有那个文件或目录 这是因为系统还没有生成那个文件列表库。你可以使用updatedb命令立即生成（更新）这个库。如果你的服务器上正跑着重要的业务，那么你最好不要去运行这个命令，因为一旦运行，服务器的压力会变大。这个数据库默认情况下每周更新一次。所以你用locate命令去搜索一个文件，正好是在两次更新时间段内，那你肯定是得不到结果的。你可以到/etc/updated.conf去配置这个数据库生成（更新）的规则。locate命令用的也并不多，所以你只要明白有这么一个东西即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112[root@localhost test]# updatedb[root@localhost test]# locate passwd/etc/passwd/etc/passwd-/etc/pam.d/passwd/etc/security/opasswd/usr/bin/gpasswd/usr/bin/grub2-mkpasswd-pbkdf2/usr/bin/passwd/usr/lib/firewalld/services/kpasswd.xml/usr/lib64/security/pam_unix_passwd.so/usr/sbin/chpasswd/usr/sbin/lpasswd/usr/sbin/saslpasswd2/usr/share/awk/passwd.awk/usr/share/doc/passwd-0.79/usr/share/doc/passwd-0.79/AUTHORS/usr/share/doc/passwd-0.79/COPYING/usr/share/doc/passwd-0.79/ChangeLog/usr/share/doc/passwd-0.79/NEWS/usr/share/locale/ar/LC_MESSAGES/passwd.mo/usr/share/locale/as/LC_MESSAGES/passwd.mo/usr/share/locale/ast/LC_MESSAGES/passwd.mo/usr/share/locale/bg/LC_MESSAGES/passwd.mo/usr/share/locale/bn/LC_MESSAGES/passwd.mo/usr/share/locale/bn_IN/LC_MESSAGES/passwd.mo/usr/share/locale/bs/LC_MESSAGES/passwd.mo/usr/share/locale/ca/LC_MESSAGES/passwd.mo/usr/share/locale/cs/LC_MESSAGES/passwd.mo/usr/share/locale/cy/LC_MESSAGES/passwd.mo/usr/share/locale/da/LC_MESSAGES/passwd.mo/usr/share/locale/de/LC_MESSAGES/passwd.mo/usr/share/locale/el/LC_MESSAGES/passwd.mo/usr/share/locale/en_GB/LC_MESSAGES/passwd.mo/usr/share/locale/es/LC_MESSAGES/passwd.mo/usr/share/locale/et/LC_MESSAGES/passwd.mo/usr/share/locale/eu/LC_MESSAGES/passwd.mo/usr/share/locale/fa/LC_MESSAGES/passwd.mo/usr/share/locale/fi/LC_MESSAGES/passwd.mo/usr/share/locale/fr/LC_MESSAGES/passwd.mo/usr/share/locale/gl/LC_MESSAGES/passwd.mo/usr/share/locale/gu/LC_MESSAGES/passwd.mo/usr/share/locale/he/LC_MESSAGES/passwd.mo/usr/share/locale/hi/LC_MESSAGES/passwd.mo/usr/share/locale/hr/LC_MESSAGES/passwd.mo/usr/share/locale/hu/LC_MESSAGES/passwd.mo/usr/share/locale/hy/LC_MESSAGES/passwd.mo/usr/share/locale/id/LC_MESSAGES/passwd.mo/usr/share/locale/is/LC_MESSAGES/passwd.mo/usr/share/locale/it/LC_MESSAGES/passwd.mo/usr/share/locale/ja/LC_MESSAGES/passwd.mo/usr/share/locale/ka/LC_MESSAGES/passwd.mo/usr/share/locale/kn/LC_MESSAGES/passwd.mo/usr/share/locale/ko/LC_MESSAGES/passwd.mo/usr/share/locale/ku/LC_MESSAGES/passwd.mo/usr/share/locale/lo/LC_MESSAGES/passwd.mo/usr/share/locale/mk/LC_MESSAGES/passwd.mo/usr/share/locale/ml/LC_MESSAGES/passwd.mo/usr/share/locale/mr/LC_MESSAGES/passwd.mo/usr/share/locale/ms/LC_MESSAGES/passwd.mo/usr/share/locale/my/LC_MESSAGES/passwd.mo/usr/share/locale/nb/LC_MESSAGES/passwd.mo/usr/share/locale/nds/LC_MESSAGES/passwd.mo/usr/share/locale/nl/LC_MESSAGES/passwd.mo/usr/share/locale/nn/LC_MESSAGES/passwd.mo/usr/share/locale/or/LC_MESSAGES/passwd.mo/usr/share/locale/pa/LC_MESSAGES/passwd.mo/usr/share/locale/pl/LC_MESSAGES/passwd.mo/usr/share/locale/pt/LC_MESSAGES/passwd.mo/usr/share/locale/pt_BR/LC_MESSAGES/passwd.mo/usr/share/locale/ro/LC_MESSAGES/passwd.mo/usr/share/locale/ru/LC_MESSAGES/passwd.mo/usr/share/locale/si/LC_MESSAGES/passwd.mo/usr/share/locale/sk/LC_MESSAGES/passwd.mo/usr/share/locale/sl/LC_MESSAGES/passwd.mo/usr/share/locale/sq/LC_MESSAGES/passwd.mo/usr/share/locale/sr/LC_MESSAGES/passwd.mo/usr/share/locale/sr@latin/LC_MESSAGES/passwd.mo/usr/share/locale/sv/LC_MESSAGES/passwd.mo/usr/share/locale/ta/LC_MESSAGES/passwd.mo/usr/share/locale/te/LC_MESSAGES/passwd.mo/usr/share/locale/tr/LC_MESSAGES/passwd.mo/usr/share/locale/uk/LC_MESSAGES/passwd.mo/usr/share/locale/ur/LC_MESSAGES/passwd.mo/usr/share/locale/vi/LC_MESSAGES/passwd.mo/usr/share/locale/wa/LC_MESSAGES/passwd.mo/usr/share/locale/zh_CN/LC_MESSAGES/passwd.mo/usr/share/locale/zh_TW/LC_MESSAGES/passwd.mo/usr/share/man/cs/man1/gpasswd.1.gz/usr/share/man/de/man1/gpasswd.1.gz/usr/share/man/de/man8/chpasswd.8.gz/usr/share/man/fr/man1/gpasswd.1.gz/usr/share/man/fr/man8/chpasswd.8.gz/usr/share/man/hu/man1/gpasswd.1.gz/usr/share/man/it/man1/gpasswd.1.gz/usr/share/man/it/man8/chpasswd.8.gz/usr/share/man/ja/man1/gpasswd.1.gz/usr/share/man/ja/man1/passwd.1.gz/usr/share/man/ja/man8/chpasswd.8.gz/usr/share/man/man1/gpasswd.1.gz/usr/share/man/man1/grub2-mkpasswd-pbkdf2.1.gz/usr/share/man/man1/lpasswd.1.gz/usr/share/man/man1/passwd.1.gz/usr/share/man/man1/sslpasswd.1ssl.gz/usr/share/man/man8/chpasswd.8.gz/usr/share/man/pt_BR/man1/gpasswd.1.gz/usr/share/man/ru/man1/gpasswd.1.gz/usr/share/man/ru/man8/chpasswd.8.gz/usr/share/man/zh_CN/man1/gpasswd.1.gz/usr/share/man/zh_CN/man8/chpasswd.8.gz/usr/share/man/zh_TW/man8/chpasswd.8.gz[root@localhost test]# find 这个搜索工具是用的最多的一个，所以请你务必要熟悉它。 语法： find [路径] [参数] 下面介绍几个常用的参数: -atime +n ：访问或执行时间大于n天的文件 -ctime +n ：写入、更改inode属性（例如更改所有者、权限或者连接）时间大于n天的文件 -mtime +n ：写入时间大于n天的文件 文件的Access time，atime是在读取文件或者执行文件时更改的。文件的Modified time，mtime是在写入文件时随文件内容的更改而更改的。文件的Create time，ctime是在写入文件、更改所有者、权限或链接设置时随Inode的内容更改而更改的。因此，更改文件的内容即会更改mtime和ctime，但是文件的ctime可能会在mtime未发生任何变化时更改，例如，更改了文件的权限，但是文件内容没有变化。 如何获得一个文件的atime mtime 以及ctime ？ ls -l 命令可用来列出文件的atime、ctime 和mtime。 ls -lc filename 列出文件的 ctime ls -lu filename 列出文件的 atime ls -l filename 列出文件的 mtime atime不一定在访问文件之后被修改，因为：使用ext3文件系统的时候，如果在mount的时候使用了noatime参数那么就不会更新atime的信息。而这是加了noatime取消了, 不代表真实情況。反正, 这三个time stamp都放在inode中。若 mtime, atime修改inode就一定會改, 既然inode改了, 那ctime也就跟著要改了。 继续讲find常用的参数。 -name filename 直接查找该文件名的文件，这个使用最多了。1234567[root@localhost test]# ls111 123 test test1 test2 test3 test4 test5[root@localhost test]# find /tmp/test -name test/tmp/test/tmp/test/test/tmp/test/test4/test[root@localhost test]# -type：通过文件类型查找。文件类型在前面部分已经简单介绍过，相信你已经大体上了解了。type包含了f,b,c,d,l, s等等。后续的内容还会介绍文件类型的。1234567891011[root@localhost test]# mkdir file1[root@localhost test]# mkdir file1/file2[root@localhost test]# touch file1/file3[root@localhost test]# touch file1/file2/file4[root@localhost test]# find ./file1 -type d./file1./file1/file2[root@localhost test]# find ./file1 -type f./file1/file2/file4./file1/file3[root@localhost test]# Linux文件类型在前面的内容中简单介绍了普通文件(-)，目录(d)等，在Linux文件系统中，主要有以下几种类型的文件。 正规文件（regular file）：就是一般类型的文件，当用ls –l查看某个目录时，第一个属性为“-”的文件就是正规文件，或者叫普通文件。正规文件又可分成纯文字文件（ascii）和二进制文件（binary）。纯文本文件是可以通过cat, more, less等工具直接查看内容的，而二进制文件并不能。例如我们用的命令/usr/bin/ls这就是一个二进制文件。 目录（directory）：这个很容易理解，就是目录，跟Windows下的文件夹一个意思，只不过在Linux中我们不叫文件夹，而是叫做目录。ls –l查看第一个属性为“d”。 连接档（link）：ls –l查看第一个属性为“l”，类似Windows下的快捷方式。这种文件在Linux中很常见，而且在日常的系统运维工作中用的很多，所以你要特意留意一下这种类型的文件。在后面还会有介绍。 设备档（device）：与系统周边相关的一些档案，通常都集中在/dev这个目录之下！通常又分为两种：区块(block) 设备档 ：就是一些储存数据，以提供系统存取的接口设备，简单的说就是硬盘啦！例如你的一号硬盘的代码是/dev/hda1 等等的档案啦！第一个属性为“b”；字符(character)设备档：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为“c”。 Linux文件后缀名在Linux系统中，文件的后缀名并没有具体意义，也就是说，你加或者不加，都无所谓。但是为了容易区分，Linux爱好者们都习惯给文件加一个后缀名，这样当用户看到这个文件名时就会很快想到它到底是一个什么文件。例如1.sh,2.tar.gz,my.cnf,test.zip等等，如果你首次接触这些文件，你也许会感到很晕，没有关系，随着学习的深入，你就会逐渐的了解这些文件了。列举的几个文件名中1.sh代表它是一个shell script ，2.tar.gz代表它是一个压缩包，my.cnf代表它是一个配置文件，test.zip代表它是一个压缩文件。 另外需要你知道的是，早期Unix系统文件名最多允许14个字符，而新的Unix或者Linux系统中，文件名最长可以到达 256个字符！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecureCRT的使用]]></title>
    <url>%2F2018%2F05%2F17%2FSecureCRT%2F</url>
    <content type="text"><![CDATA[SecureCRT简介SecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。 解决SecureCRT中文乱码本地windows机器。修改SecureCRT的设置。找到“选项”-&gt;“会话选项”-&gt;“外观”： 字符编码设置为utf-8。 字体设置，选择中文字体，例如新宋体。 重新启动SecureCRT即可 发送文件到Linux系统 右键单击SecureCRT控制台左上角的ip地址 找到“连接SFTP标签页(S)”并单击，进入SFTP标签页 可以使用help命令查看SFTP下面所有的功能 使用命令lcd进入客户端要发送给服务器所在文件的文件夹中，例如：lcd D:\software 使用命令lls可查看该文件下所有的文件，例如：lls D:\software 使用命令cd进入服务器接受文件的文件中。例如： cd /usr/jdk 使用命令put 加上要发送的文件名即可发送文件到服务器，例如：put 1.txt 使用命令ls查看服务器是否收到该文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SecureCRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7中查看本机ip地址]]></title>
    <url>%2F2018%2F05%2F17%2FCentOS_1%2F</url>
    <content type="text"><![CDATA[可以输入以下命令查询1ip addr 1ifconfig 如果输入ifconfig，出现1-bash: ifconfig: command not found 说明没有ifconfig，可以输入以下命令安装net-tools package1sudo yum install net-tools 安装完成后，则可以用ifconfig命令来查询ip地址。 输入命令会出现3个条目，CentOS的ip地址是ens33条目中的inet值。发现ens33没有inet这个属性，那么就没法通过ip地址做远程连接了。接着来输入以下命令来查看ens33网卡的配置： 1vi /etc/sysconfig/network-scripts/ifcfg-ens33 vi是Linux内置的文本编辑器命令，打开文件的意思。 从配置清单中可以发现CentOS7默认是不启动网卡的（ONBOOT=no）。把这一项改为yes（ONBOOT=yes）,如下图所示： vi打开时是处于只读状态的，可以按insert键或者A使其处于编辑状态。 修改完成后，按Esc退出，然后输入命令:wq，再按Enter即可。 :wq是保存然后退出的意思；:q!是不保存直接退出的意思最后输入以下命令重启网络服务即可： 1sudo service network restart 然后我们再输入ip attr或者ifconfig,即可看到ip地址123456789101112131415[root@localhost ~]# ip attrObject &quot;attr&quot; is unknown, try &quot;ip help&quot;.[root@localhost ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:6f:51:d5 brd ff:ff:ff:ff:ff:ff inet 192.168.43.137/24 brd 192.168.43.255 scope global noprefixroute dynamic ens33 valid_lft 3198sec preferred_lft 3198sec inet6 fe80::dc72:7667:d658:eff6/64 scope link noprefixroute valid_lft forever preferred_lft forever 这里的192.168.43.137即是我们需要的ip地址。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux入门（四）初步进入 Linux世界]]></title>
    <url>%2F2018%2F05%2F17%2FLinux_4%2F</url>
    <content type="text"><![CDATA[Linux的启动过程Linux的启动其实和Windows的启动过程很类似，不过Windows我们是无法看到启动信息的，而Linux启动时我们会看到许多启动信息，例如某个服务是否启动。 Linux系统的启动过程大体上可分为五部分： 内核的引导 运行init 系统初始化 建立终端 用户登录系统 学会使用快捷键Ctrl+C：这个是用来终止当前命令的快捷键，当然你也可以输入一大串字符，不想让它运行直接Ctrl + C，光标就会跳入下一行。 Tab：这个键是最有用的键了，因为当你打一个命令打一半时，它会帮你补全的。不光是命令，当你打一个目录时，同样可以补全，不信你试试。 Ctrl+D：退出当前终端，同样你也可以输入exit。 Ctrl+Z：暂停当前进程，比如你正运行一个命令，突然觉得有点问题想暂停一下，就可以使用这个快捷键。暂停后，可以使用fg恢复它。 Ctrl+L：清屏，使光标移动到第一行，同样你也可以输入clear。 查询帮助文档——man有问题找男人——man这个man通常是用来看一个命令的帮助文档的。例如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869[root@localhost ~]# man lsLS(1) User Commands LS(1)NAME ls - list directory contentsSYNOPSIS ls [OPTION]... [FILE]...DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is speci鈥[m fied. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author Manual page ls(1) line 1 (press h for help or q to quit)...skipping...LS(1) User Commands LS(1)NAME ls - list directory contentsSYNOPSIS ls [OPTION]... [FILE]...DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is speci鈥[m fied. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE scale sizes by SIZE before printing them; e.g., &apos;--block-size=M&apos; prints sizes in units of 1,048,576 bytes; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first -C list entries by columns --color[=WHEN] colorize the output; WHEN can be &apos;never&apos;, &apos;auto&apos;, or &apos;always&apos; (the default); more info below 输入man ls,其实格式为man+ 命令 你就会看到相关的帮助文档了。从命令的介绍到命令的参数以及用法介绍的都非常详细的。不错吧。 Linux系统目录结构登录系统后，在当前命令窗口下输入 ls / 你会看到12[root@localhost ~]# ls /bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var /bin bin是Binary的缩写。这个目录存放着最经常使用的命令。 /boot 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev dev是Device(设备)的缩写。该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lib64 包含许多被/bin和/sbin中的程序使用的库文件。目录/usr/lib中含有更多用于用户程序的库文件。 /media Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下。 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all。 /root 该目录为系统管理员，也称作超级权限者的用户主目录。 /run 里面的东西是系统运行时需要的,不能随便删除。但是重启的时候应该抛弃。下次系统运行时重新生成。 /sbin s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /srv 该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs ，sysfs文件系统集成了下面3种文件系统的信息： 针对进程信息的proc文件系统 针对设备的devfs文件系统 针对伪终端的devpts文件系统 该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统种被创建。 /tmp 这个目录是用来存放一些临时文件的。 /usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与Windows下的program files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin，/sbin，/usr/bin，/usr/sbin: 这是系统预设的执行文件的放置目录，比如ls就是在/bin/ls目录下的。值得提出的是，/bin, /usr/bin是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin则是给root使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。 如何正确关机其实，在Linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 Linux和Windows不同，在Linux底下，由于每个程序（或者说是服务）都是在在背景下执行的，因此，在你看不到的屏幕背后其实可能有相当多人同时在你的主机上面工作，例如浏览网页啦、传送信件啦以 FTP传送档案啦等等的，如果你直接按下电源开关来关机时，则其它人的数据可能就此中断！那可就伤脑筋了！此外，最大的问题是，若不正常关机，则可能造成文件系统的毁损（因为来不及将数据回写到档案中，所以有些服务的档案会有问题！）。 如果你要关机，必须要保证当前系统中没有其他用户在线。可以下达who这个指令，而如果要看网络的联机状态，可以下达netstat -a这个指令，而要看背景执行的程序可以执行ps -aux这个指令。使用这些指令可以让你稍微了解主机目前的使用状态！ 关于关机的一些指令 sync 将数据由内存同步到硬盘中。 shutdown 关机指令，你可以man shutdown来看一下帮助文档。例如你可以运行如下命令关机： shutdown –h 101This server will shutdown after 10 mins 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。 shutdown –h now 立马关机 shutdown –h 20:25 系统会在今天20:25关机 shutdown –h +10 十分钟后关机 shutdown –r now 系统立马重启 shutdown –r +10 系统十分钟后重启 reboot 就是重启，等同于shutdown –r now halt关闭系统，等同于shutdown –h now和poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux入门（三）Linux操作系统的安装]]></title>
    <url>%2F2018%2F05%2F17%2FLinux_3%2F</url>
    <content type="text"><![CDATA[因为作为练习用，所以直接在Windows中安装VMware Workstations，然后在VMware Workstations中安装Linux系统。 VMware Workstations来自百度百科的介绍 VMware Workstation允许操作系统(OS)和应用程序(Application)在一台虚拟机内部运行。虚拟机是独立运行主机操作系统的离散环境。在VMware Workstation中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机(例如一个公司局域网)，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。 为什么选择CentOSCentOS是RHEL（Red Hat Enterprise Linux）源代码再编译的产物，而且在RHEL的基础上修正了不少已知的Bug ，相对于其他Linux发行版，其稳定性值得信赖。所以在这里选择CentOS。 VMware Workstations中安装CentOS关于VMware Workstations中安装CentOS网上有很多资源，可以自行查找。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux入门（二）图形界面还是命令窗口]]></title>
    <url>%2F2018%2F05%2F16%2FLinux_2%2F</url>
    <content type="text"><![CDATA[对于Linux的应用，我想大多数都是用在服务器领域，对于服务器来讲真的没有必要跑一个图形界面。所以我们平时安装Linux操作系统时往往是不安装图形界面的。说到这里也许你会有疑问，图形界面还能选择装或者不装？ 是的，虽然Linux和微软的Windows一样同位操作系统，但是它们有一个很大的区别就是Windows操作系统的图形界面是和内核一体的，俗称微内核，而Linux操作系统图形界面就像一个软件一样，和内核并不是一体的。所以Linux你可以选择不安装图形界面，这样不仅不影响服务器的正常使用还可以节省系统资源的开销，何乐而不为呢？ 如果你对Linux超级感兴趣，想使用Linux就像使用Windows一样，那你可以安装图形界面，可以像Windows一样来体验Linux也是蛮不错的。但是如果你想成为一个专业的Linux系统工程师，那建议你从第一天开始就不要去安装图形界面，从命令窗口开始熟悉它。 另外一点值得说的是，日常应用中，我们都是远程管理服务器的，不可能开着图形界面来让你去操作，虽然目前也有相应的工具支持远程图形连接服务器，可是那样太消耗网络带宽资源，所以从这方面来考虑还是建议不要使用图形界面。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux入门（一）初始Linux]]></title>
    <url>%2F2018%2F05%2F16%2FLinux_1%2F</url>
    <content type="text"><![CDATA[在介绍Linux前，我想先针对大家如何对Linux的发音说一下。我发现我身边的朋友对Linux的发音大致有这么几种： “里那克斯”与“里你克斯”“里扭克斯”等。其实官方的标准发音为 [‘li:nэks]，因为这个发音是创始人Linus的发音。如果你不认识这个音标，那么就读成“里那克斯”。而我习惯发音成“里扭克斯”，当然你发音成什么，并没有人会说你，完全是一个人的习惯而已。 操作系统的发展史Unix1965年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑。 为了解决数量不够用的问题,1965年左右由贝尔实验室、麻省理工学院以及通用电气共同发起了Multics项目，想让大型主机支持300台终端。 1969年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究。 1969年从这个项目中退出的Ken Thompson当时在实验室无聊时，为了让一台空闲的电脑上能够运行“星际旅行”游行，在8月份左右趁着其妻子探亲的时间，用了1个月的时间 编写出了Unix操作系统的原型。 1970年，美国贝尔实验室的Ken Thompson，以BCPL语言为基础，设计出很简单且很接近硬件的B语言（取BCPL的首字母），并且他用B语言写了第一个Unix操作系统。 因为B语言的跨平台性较差，为了能够在其他的电脑上也能够运行这个非常棒的Unix操作系统，Dennis Ritchie和Ken Thompson从B语言的基础上准备研究一个更好的语言。 1972年，美国贝尔实验室的Dennis Ritchie在B语言的基础上最终设计出了一种新的语言，他取了BCPL的第二个字母作为这种语言的名字，这就是C语言。 1973年初，C语言的主体完成。Thompson和Ritchie迫不及待地开始用它完全重写了现在大名鼎鼎的Unix操作系统。 Minix因为AT&amp;T(通用电气)的政策改变，在Version7 Unix推出之后，发布新的使用条款，将Unix源代码私有化，在大学中不再能使用Unix源代码。AndrewS.Tanenbaum(塔能鲍姆)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与Unix兼容的操作系统，以避免版权上的争议。他以小型Unix（mini-UNIX）之意，将它称为Minix。 Linux因为Minix只是教学使用，因此功能并不强，因此Torvalds利用GNU的bash当做开发环境，gcc当做编译工具，编写了Linux内核-v0.02，但是一开始Linux并不能兼容Unix，即Unix上跑的应用程序不能在Linux上跑，即应用程序与内核之间的接口不一致，因为Unix是遵循POSIX规范的，因此Torvalds修改了Linux，并遵循POSIX（Portable Operating System Interface，他规范了应用程序与内核的接口规范）； 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件。 操作系统的发展Unix和Linux的应用范围Linux的应用领域ios的来源 Minix没有火起来的原因 Minix的创始人说，Minix3没有统治世界是源于他在1992年犯下的一个错误，当时他认为BSD必然会一统天下，因为它是一个更稳定和更成熟的系统，其它操作系统难以与之竞争。因此他的Minix的重心集中在教育上。四名BSD开发者已经成立了一家公司销售BSD系统，他们甚至还有一个有趣的电话号码1-800-ITS-UNIX。然而他们正因为这个电话号码而惹火上身。美国电话电报公司因电话号码而提起诉讼。官司打了三年才解决。在此期间，BSD陷于停滞，而Linux则借此一飞冲天。他的错误在于没有意识官司竟然持续了如此长的时间，以及BSD会因此受到削弱。如果美国电话电报公司没有起诉，Linux永远不会流行起来，BSD将统治世界。 Linux的不同版本以及应用领域Linux内核版本内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。 Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环： 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。 开发版：由于要试验各种解决方案，所以变化很快。 Linux官网，所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中。 Linux发行版本Linux发行版(也被叫做GNU/Linux发行版)说简单点就是将Linux内核与应用软件做一个打包。较知名的发行版有：Ubuntu、RedHat、CentOS、Debain、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。 RHEL (RedHat Enterprise Linux)RHEL的地位就像Ubuntu在Linux桌面发行版中的地位一样。Red Hat Enterprise Linux背后的红帽公司是Linux早期最大的企业。多年来，他们不断地对RHEL进行改进，确保大多数软件包和硬件都是RHEL支持或“认证”的。除了认证状态外，长期支持在顶级Linux服务器操作系统中也很重要。该公司声称，全球“财富”500强中有90％的公司使用RHEL，这个数字可以说是非常多了。 CentOS如果你不想花钱，但又希望有使用RHEL一般的体验，最好的方法是下载免费的Linux服务器发行版CentOS。从另一个角度来看，这是社区支持的RHEL，但是没有Red Hat的支持。CentOS与RHEL是二进制兼容的，RHEL也成为了该选项很重要的加分点。就像RHEL一样，CentOS软件库包含经过测试的软件，它对生产系统来说是安全和稳定的。说到控制面板，cPanel让CentOS可以提供更好的支持。如果熟悉.rpm软件包和yum软件包管理器，CentOS就是最佳Linux服务器操作系统。 Ubuntu LTS与RHEL和CentOS相比，Ubuntu LTS获取软件包的速度更快。这个选择再次归结为用户的特殊需求，如果想要某些应用程序和软件上的所有最新功能，请转到Ubuntu。此外，它拥有广泛的社区，对于愿意跳入Linux世界的初学者而言，也建议这样做。 谈到性能，Ubuntu提供了一个灵活的性能。开发者可以选择Ubuntu服务器选项，它提供了一些有用的软件包比如邮件服务器，LAMP服务器，Samba文件服务器，OpenStackMitaka，Nginx等。该发行版的5年LTS支持也保证了初学者的使用，开发者可以设置媒体服务器，电子邮件服务器或游戏服务器等场景。 Debian为什么一些流行的Linux发行版是基于Debian的呢？这归结于Debian的稳定性。尽管开发者希望在Debian上做的任何事情都可以在Ubuntu上实现，但是如果高于平均水平，稳定性就变得非常重要，我们建议开发者选择Debian。另外要记住的是，Debian只附带免费软件。与Ubuntu相比，它更轻巧，速度更快，这使得它成为旧硬件的合适选择。 简而言之，如果你正在考虑安全问题并且熟悉Linux的企业环境，并且你需要一个Linux服务器操作系统，相比于Ubuntu，选择Debian更合适。 SLES (SUSE Linux Enterprise Server)就像RHEL和Canonical一样，SUSE在开源世界中也是一个非常有名的发行版。它始于1992年，是第一家为企业客户推销Linux的公司。该公司的主要产品是SUSE Linux Enterprise Server。 最近与SAP和微软达成合作关系，这也将其带入了不同的企业服务市场。 使用SLES（和OpenSUSE）的一大优势是YaST软件管理系统，这使许多复杂的任务变得更简单和自动化。它有用户的GUI和命令行界面，这就是SLES也被称为管理友好型Linux发行版的原因。它是为正在寻找多用途Linux服务器发行版的高级用户而打造的。 应用领域个人桌面领域此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺点，一直被windows所压制，但近些年来随着ubuntu、fedora等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高。 典型代表：ubuntu、fedora、suse linux等 服务器领域linux在服务器领域的应用是其重要分支。 linux免费、稳定、高效等特点在这里得到了很好的体现，但早期因为维护、运行等原因同样受到了很大的限制，但近些年来linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛。 典型代表：Red Hat公司的AS系列、完全开源的debian系列、suse EnterPrise11系列等。 嵌入式领域linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高。 主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、等都是其应用领域，得到了摩托罗拉、三星、NEC、Google等公司的大力推广。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中对File的操作]]></title>
    <url>%2F2018%2F04%2F20%2FFile%2F</url>
    <content type="text"><![CDATA[一直以来对File类中的API不太了解，今天借着对《Java编程思想（第4版）》中第18.1章File类的学习，做一个相对深入的研究。 创建创建目录123456789101112131415161718 /** * 创建目录 * @param as_Path 路径 * @return 创建后的文件对象 * @throws Exception 方法异常 * */public static File uf_CreateDirectory(String as_Path) throws Exception&#123; File file=new File(as_Path); if(file.exists())&#123; if(!file.isDirectory())&#123; throw new Exception("路径存在但不是目录！"); &#125; &#125; //如果文件夹不存在，则会创建，并返回true;如果存在，则不会创建，并返回false file.mkdirs(); return file;&#125; 在这里普及一下mkdirs()和mkdir()的区别： mkdirs()可以建立多级文件夹， mkdir()只会建立一级的文件夹， 如下：1new File("/tmp/one/two/three").mkdirs(); 执行后， 会建立tmp/one/two/three四级目录1new File("/tmp/one/two/three").mkdir(); 则不会建立任何目录， 因为找不到/tmp/one/two目录， 结果返回false 创建文件12345678910111213141516171819202122232425262728293031/** * 创建文件 * @param as_Path 路径 * @param isDelete 如果文件已存在，是否删除 * @return 创建后的文件对象 * @throws Exception 方法异常 */public static File uf_CreateFile(String as_Path,boolean isDelete) throws Exception&#123; File file=new File(as_Path); if(file.exists())&#123; if(isDelete)&#123; //删除文件 file.delete(); file.createNewFile(); &#125; &#125;else&#123; if(as_Path.endsWith(File.separator))&#123; throw new Exception("创建单个文件" +as_Path + "失败，目标文件不能为目录！"); &#125; //判断目标文件所在的目录是否存在 if(file.getParentFile()!=null)&#123; if(!file.getParentFile().exists())&#123; if(!file.getParentFile().mkdirs()) &#123; throw new Exception("创建目标文件所在目录失败！"); &#125; &#125; &#125; file.createNewFile(); &#125; return file;&#125; 在创建文件时，必须保证目标文件不存在，而且父目录存在，否则会创建失败 删除删除目录12345678910111213141516171819202122232425262728/** * 删除目录（包括子目录） * @param as_Path 要删除的目录路径 * @param isIncludeRoot 是否包含路径本身 * @throws Exception 方法异常 */public static void uf_DelTree(String as_Path,boolean isIncludeRoot) throws Exception&#123; File file=new File(as_Path); if(!file.exists())&#123; throw new Exception("要删除的路径不存在！"); &#125; if(!file.isDirectory())&#123; throw new Exception("路径存在，但不是目录！"); &#125; File[] files=file.listFiles(); String fileName; for(File file1:files)&#123; fileName=file1.getName(); if(file1.isDirectory())&#123; FileHelper.uf_DelTree(as_Path+File.separator+fileName, true); &#125;else&#123; file1.delete(); &#125; &#125; if(isIncludeRoot)&#123; file.delete(); &#125;&#125; 在这里普及一下File类中的list()和listFiles()方法的区别： list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组 listFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组 list()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); String[] fileNames=file.list(); for(String fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567build.xmlDocumentation1.javaDocumentation2.javaDocumentation3.javaHelloDate.javaHelloDate1.javaShowProperties.java listFiles()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); File[] fileNames=file.listFiles(); for(File fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567E:\thinkingInJava\Think in Java 4 code\object\build.xmlE:\thinkingInJava\Think in Java 4 code\object\Documentation1.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation2.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation3.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate1.javaE:\thinkingInJava\Think in Java 4 code\object\ShowProperties.java 删除文件123456789101112131415161718/** * 删除文件 * @param as_Path 要删除的文件路径 * @throws Exception 方法异常 */public static void uf_DelFile(String as_Path) throws Exception&#123; File file=new File(as_Path); if(!file.exists())&#123; throw new Exception("要删除的文件不存在！"); &#125; if(as_Path.endsWith(File.separator))&#123; throw new Exception("删除单个文件" +as_Path + "失败，目标文件不能为目录！"); &#125; if(!file.isFile())&#123; throw new Exception("删除单个文件" +as_Path + "失败，目标文件不是文件！"); &#125; file.delete();&#125; 修改复制文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 复制文件 * @param as_SourFile 源文件路径 * @param as_DestFile 目标文件路径 * @param isOvercast 如果目标文件存在是否覆盖 * @throws Exception 方法异常 */public static File uf_CopyFile(String as_SourFile,String as_DestFile,boolean isOvercast) throws Exception&#123; File sourFile=new File(as_SourFile); if(!sourFile.exists())&#123; throw new Exception("复制文件" +as_SourFile + "失败，源文件不存在！"); &#125; if(!sourFile.isFile())&#123; throw new Exception("复制文件" +as_SourFile + "失败，源文件不是文件！"); &#125; File destFile=new File(as_DestFile); if(destFile.exists())&#123; if(!destFile.isFile())&#123; throw new Exception("复制文件" +as_SourFile + "失败，目标路径"+as_DestFile+"存在,但不是文件！"); &#125; if(!isOvercast)&#123; return destFile; &#125; &#125; FileInputStream fileInputStream=null; FileOutputStream fileOutputStream=null; try &#123; fileInputStream=new FileInputStream(sourFile); fileOutputStream=new FileOutputStream(destFile); byte[] buf=new byte[1024]; int len=0; while((len=fileInputStream.read(buf))!=-1)&#123; fileOutputStream.write(buf, 0, len); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception(e); &#125;finally&#123; if(fileInputStream!=null)&#123; fileInputStream.close(); &#125; if(fileOutputStream!=null)&#123; fileOutputStream.close(); &#125; &#125; return destFile;&#125; 复制目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 目录复制(含子目录) * @param as_sPath 源路径 * @param as_dPath 目标路径 * @param ab_IsIncludeRoot 是否包含源路径本身 * @throws Exception 方法异常 */public static void uf_CopyTree(String as_sPath, String as_dPath, boolean ab_IsIncludeRoot) throws Exception&#123; File lo_sFile = new File(as_sPath); if (!lo_sFile.exists()) throw new Exception("源路径并不存在。"); if (!lo_sFile.isDirectory()) throw new Exception("源路径并非目录。"); File lo_dFile = new File(as_dPath); if (!lo_dFile.exists())&#123; lo_dFile.mkdirs(); &#125; if (!lo_dFile.isDirectory()) throw new Exception("目标路径并非目录。"); File lo_NewFile, lo_File; String ls_Name; if (ab_IsIncludeRoot) &#123; ls_Name = lo_sFile.getName(); lo_NewFile = new File(as_dPath +File.separator + ls_Name); if (!lo_NewFile.exists()) &#123; lo_NewFile.mkdir(); &#125; else &#123; if (!lo_NewFile.isDirectory()) throw new Exception("目标路径存在但并非目录。"); &#125; FileHelper.uf_CopyTree(as_sPath, as_dPath + File.separator + ls_Name, false); &#125; else &#123; File[] lo_Files = lo_sFile.listFiles(); for (int ii = 0; ii &lt; lo_Files.length; ii++) &#123; lo_File = lo_Files[ii]; ls_Name = lo_File.getName(); if (lo_File.isDirectory()) &#123; lo_NewFile = new File(as_dPath + File.separator + ls_Name); if (!lo_NewFile.exists()) &#123; lo_NewFile.mkdir(); &#125; else &#123; if (!lo_NewFile.isDirectory()) throw new Exception("目标路径存在但并非目录。"); &#125; FileHelper.uf_CopyTree(as_sPath + File.separator + ls_Name, as_dPath + File.separator + ls_Name, false); &#125; else &#123; FileHelper.uf_CopyFile(as_sPath + File.separator + ls_Name, as_dPath + File.separator + ls_Name, true); &#125; &#125; &#125;&#125; 移动文件123456789101112131415/** * 移动文件 * @param as_sFile 源文件路径 * @param as_dFile 目标文件路径 * @param ab_IsOvercast 目标文件存在是否覆盖 * @return 移动后的File对象 * @throws Exception 方法异常 */public static File uf_MoveFile(String as_sFile, String as_dFile, boolean ab_IsOvercast) throws Exception&#123; File lo_sFile = new File(as_sFile); File lo_dFile = FileHelper.uf_CopyFile(as_sFile, as_dFile, ab_IsOvercast); lo_sFile.delete(); return lo_dFile;&#125; 查看首先，再普及一下File类中的list()和listFiles()方法的区别： list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组 listFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组 list()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); String[] fileNames=file.list(); for(String fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567build.xmlDocumentation1.javaDocumentation2.javaDocumentation3.javaHelloDate.javaHelloDate1.javaShowProperties.java listFiles()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); File[] fileNames=file.listFiles(); for(File fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567E:\thinkingInJava\Think in Java 4 code\object\build.xmlE:\thinkingInJava\Think in Java 4 code\object\Documentation1.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation2.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation3.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate1.javaE:\thinkingInJava\Think in Java 4 code\object\ShowProperties.java 目录列表器对符合条件的文件进行筛选12345678910111213141516171819202122232425262728/** * 筛选符合条件的文件 * @param as_sFile 目录文件 * @param reg 要筛选的文件正则表达式 * @return 符合条件的文件集合 * @throws Exception */public static String[] uf_ListFile(String as_sFile,final String reg)throws Exception&#123; File path = new File(as_sFile); if (!path.exists()) throw new Exception("源路径并不存在。"); if (!path.isDirectory()) throw new Exception("源路径并非目录。"); String[] list; if(reg==null||"".equals(reg)) list = path.list(); else //匿名内部类 list = path.list(new FilenameFilter() &#123; private Pattern pattern = Pattern.compile(reg); public boolean accept(File dir, String name) &#123; return pattern.matcher(name).matches(); &#125; &#125;); //按字母顺序排序 Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); return list;&#125; 查看源码]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>File</tag>
        <tag>Java I/O系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单点登录]]></title>
    <url>%2F2018%2F04%2F19%2FSingleSignOn%2F</url>
    <content type="text"><![CDATA[发现一篇讲解单点登录非常好的文章，直接上网址:单点登录原理与简单实现]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中MD5加密和JavaScript中MD5加密]]></title>
    <url>%2F2018%2F04%2F19%2Fmd5%2F</url>
    <content type="text"><![CDATA[Java中MD5加密废话不多说，直接上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.security.MessageDigest;import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.File;/** * &lt;p&gt; * Title: Md5Helper类 * &lt;/p&gt; * &lt;p&gt; * Description: 获取一个文件或字节数组的MD5信息摘要 */public final class Md5Helper&#123; /** * 类禁止外部实例化 */ private Md5Helper() &#123; //donone &#125; /** * 获取一个字节数组的MD5信息摘要 * * @param as_Info * 原始信息 * @return MD5信息摘要 * @throws java.lang.IllegalArgumentException * 如果参数无效 * @throws java.lang.Exception * 包含其它任何异常 */ public static byte[] uf_Md5(byte[] as_Info) throws IllegalArgumentException, Exception &#123; if ((as_Info == null) || (as_Info.length == 0)) &#123; throw new IllegalArgumentException("无效参数"); &#125; MessageDigest alga = java.security.MessageDigest.getInstance("MD5"); alga.update(as_Info); return alga.digest(); &#125; /** * 加密 * 字节数组转换为16进制显示 * @param info 字节数组 * @return 16进制显示字符串 */ public static String uf_byte2hex(byte[] info) &#123; String hs = ""; String stmp = ""; for (int n = 0; n &lt; info.length; n++) &#123; stmp = (java.lang.Integer.toHexString(info[n] &amp; 0XFF)); if (stmp.length() == 1) &#123; hs = hs + "0" + stmp; &#125; else &#123; hs = hs + stmp; &#125; &#125; return hs; &#125; /** *主方法测试 */ public static void main(String[] args) throws IllegalArgumentException, Exception &#123; System.out.println(uf_byte2hex(uf_Md5("value".getBytes())));//2063c1608d6e0baf80249c42e2be5804 System.out.println(uf_byte2hex(uf_Md5("111111".getBytes())));//96e79218965eb72c92a549dd5a330112 &#125;&#125; JavaScript中MD5加密废话不多说，直接上代码1234&lt;script src="yourUrl/md5.min.js"&gt;&lt;/script&gt; 或者： &lt;script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"&gt;&lt;/script&gt; 示例：12var hash = md5("value"); // 2063c1608d6e0baf80249c42e2be5804 var hash = md5("111111"); // 96e79218965eb72c92a549dd5a330112 参考： http://www.bootcdn.cn/blueimp-md5/ https://github.com/blueimp/JavaScript-MD5]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>js</tag>
        <tag>加密技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中取得链接参数某参数的值]]></title>
    <url>%2F2018%2F04%2F19%2FJavaScript_1%2F</url>
    <content type="text"><![CDATA[不多说，直接上代码12345678910111213function getLinkValue(paraName) &#123; var strHref = window.document.location.href; var intPos = strHref.indexOf("?"); var strRight = strHref.substr(intPos + 1); var arrTmp = strRight.split("&amp;"); for ( var i = 0; i &lt; arrTmp.length; i=i+1) &#123; var arrTemp = arrTmp[i].split("="); if (arrTemp[0].toUpperCase() == paraName.toUpperCase()) return arrTemp[1]; &#125; return ""; &#125; 用法如下：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt; New Document &lt;/TITLE&gt; &lt;META NAME="Generator" CONTENT="EditPlus"&gt; &lt;META NAME="Author" CONTENT=""&gt; &lt;META NAME="Keywords" CONTENT=""&gt; &lt;META NAME="Description" CONTENT=""&gt; &lt;script type="text/javascript"&gt; window.onload=function()&#123; alert(getLinkValue('jhg')); &#125; function getLinkValue(paraName) &#123; var strHref = window.document.location.href; var intPos = strHref.indexOf("?"); var strRight = strHref.substr(intPos + 1); var arrTmp = strRight.split("&amp;"); for ( var i = 0; i &lt; arrTmp.length; i=i+1) &#123; var arrTemp = arrTmp[i].split("="); if (arrTemp[0].toUpperCase() == paraName.toUpperCase()) return arrTemp[1]; &#125; return ""; &#125; &lt;/script&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;/BODY&gt;&lt;/HTML&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Maven实战》学习（三）]]></title>
    <url>%2F2018%2F04%2F13%2Fmaven_3%2F</url>
    <content type="text"><![CDATA[背景案例接下里的Maven学习，将引入一个真实的案例来进行学习，该案例的目的还是帮助我们理解Maven的概念， 以及展示大部分Maven项目需要面对和处理的一些问题。 简单的注册服务注册互联网账户是日常生活中再熟悉不过的一件事悄 ，作为一个用户，注册账户的时候往往需要做以下事情： 提供一个未被使用的账号ID 提供一个未被使用的Email地址 提供一个任意的显示名称 设置安全密码，并重复输入以确认 输入验证码 前往邮箱查收激活链接并单击激活账号 登录 写这些的主要目的是让读者清楚地了解这个背景案例 即账户注册服务，它的需求是什么？基于这样的一个需求 ，我们会怎样设计这个小型的系统。 需求阐述下面从软件工程的视角来分析一下该服务的需求： 需求用例 注册账户主耍场景： 1.用户访问注册页面2.系统生成验证码图片3.用户输入想要的ID、Email地址，想要的显示名称、密码、确认密码4.用户输入验证码5.用户提交注册请求6.系统检查验证码7.系统检查ID是否已经被注册，Email是否已经被注册，密码和确认密码是否一致8.系统保存未激活的账户信息9.系统生成激活链接，井发送至用户邮箱10.用户打开邮箱，访问激活链接11.系统解析激活链接，激活相关账户12.用户使用ID和密码登录 扩展场景 4a: 用户无法看清验证玛，请求重新生成 1.跳转到步骤2 6a: 系统检测到用户输入的验证码错误 1.系统提示验证码错误2.跳转到步骤2 7a: 系统检测到ID已被注册，或者Email已被注册，或者密码和确认密码不一致 1.系统提示相关错误信息2.跳转到步骤2 该用例的角色只有两个：用户和系统。“主要场景”描述了用户如何与系统一步一步地交互，并且成功完成注册; “扩展场景”则描述了一些中途发生意外的情形，比如用户输错验证码的时候，系统就需要从新生成验证码，用户也需要重新输入验证码。 简要设计接口从需求用例中可以看到，系统对外的接口包括生成验证码图片、处理注册请求、激活账户以及处理登录等。 模块结构 cn.jgh.account.service: 系统的核心，它封装了所有下层细节，对外暴露简单的接口。 cn.jgh.account.web: 顾名思义该模块包含所有与web相关的内容，包括可能的JSP、Servlet、web.xml等，它直接依赖于cn.jgh.account.service模块，使用其提供的服务。 cn.jgh.maven.account.persist: 处理账户信息的持久化，包括增、删、改、查等。根据实现，可以基于数据库或者文件。 cn.jgh.account.captcha: 处理验证码的key生成、图片生成以及验证等。这里需要第三方的类库来帮助实现这些功能。 cn.jgh.account.email: 处理邮件服务的配置、激活邮件的编写和发送。 坐标和依赖正如前面介绍的， Maven的一大功能是管理项目依赖。 为了能自动化地解析任何一个Java构件，Maven就必须将它们唯一标识，这就依赖管理的底层基础——坐标。 何为Maven坐标？Maven的世界中拥有数量非常巨大的构件，也就是平时用的一些jar、war等构件。在Maven为这些构件引人坐标概念之前，我们无法使用任何一种方式来唯一标识所有这些构件。 因此，当需要用到SpringFramework依赖的时候，大家会去SpringFramework网站寻找；当需要用到log4j依赖的时候,大家又会去Apache网站寻找。又因为各个项目的网站风格迥异，大量的时间花费在了搜索、浏览网页等工作上面。 没有统一的规范、统一的法则，该工作就无法自动化。Maven定义了这样一组规则：世界上任何一个构件都可以使用Maven坐标唯一标识，Maven坐标的元素包括groupID、artifactId、version、packaging、classifier。现在，只要我们提供正确的坐标元素，Maven就能找到对应的构件。Maven是从哪里下载构件的呢？答案其实很简单，Maven内置了一个中央仓库的地址,该中央仓库包含了世界上大部分流行的开源项目构件， Maven会在需要的时候去那里下载。 坐标详解一组Maven坐标是通过一些元素定义的，它们是groupId、artifactId、version、packaging、classifier。看下面的代码：1234&lt;groupId&gt;org.sonatype.nexus&lt;/groupId&gt; &lt;artifactId&gt;nexus-indexer&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; groupId：定义当前Maven项目隶属的实际项目。 首先，Maven项目和实际项目不一定是一对一的关系。 比如 SpringFramework这一实际项目，其对应的Maven项目会有很多，如spring-core、spring-context等。 这是由于Maven中模块的概念，因此，一个实际项目往往会被划分成很多模块。其次，groupId不应该对应项目隶属的组织或公司。原因很简单，一个组织下会有很多实际项目，如果groupId只定义到组织级别,而后面我们会看到artifactId只能定义Maven项目（模块），那么实际项目这个层将难以定义。 最后，groupId的表示方式与Java 包名的表示方式类似，通常与域名反向一一对应。 上面的代码中，groupId为org.sonatype.nexus，org.sonatype表示Sonatype公司建立的一个非盈利性组织，nexus表示Nexus这一实际项目，该groupId与域名 nexus.sonatype.org对应。 artifactId：该元素定义实际项目中的一个Maven项目（模块），推荐的做法是使用实际项目名称作为artifactId的前缀。比如上面的代码中的artifactId是nexus-indexer,使用了实际项目名nexus作为前缀，这样做的好处是方便寻找实际构件。在默认情况下，Ma­ven生成的构件，其文件名会以artifactId作为开头，如nexus-indexer-2.0.0.jar, 使用实际项目名称作为前缀之后，就能方便从一个lib文件夹中找到某个项目的一组构件。 考虑有5个项目，每个项目都有一个core模块，如果没有前缀，我们会行到很多core-1.2.jar这样的文件，加上实际项目名前缀之后， 便能很容易区分foo-core-1.2.jar、bar-core-1.2.jar…… version：该元素定义Maven项目当前所处的版本，如上面的代码中，nexus-indexer的版本是2.0.0。需要注意的是，Maven定义了一套完成的版本规范，以及快照(SNAPSHOT)的概念。 后面会详细讨论版本管理内容。 packaging：该元素定义Maven项目的打包方式。 首先，打包方式通常与所生成构件的文件扩展名对应，如上面的代码中packaging为jar。 最终的文件名为nexus-indexer-2.0.0.jar,而使用war打包方式的Maven项目，最终生成的构件会有一个.war文件，不过这不是绝对的。 其次，打包方式会影响到构建的生命周期，比如jar打包和war打包会使用不同的命令。最后，当不定义packaging的时候，Maven会使用默认值jar。 ­classifier：该元素用来帮助定义构建输出的一些附属构件。附属构件与主构件对应，如上例中的主构件是nexus-indexer-2.0.0.jar, 该项目可能还会通过使用一些插件生成如nexus-indexer-2.0.0-javadoc.jar、 nexus-indexer-2.0.0-sources.jar这样一些附属构件，其包含了Java文档和源代码。这时候，javadoc和sources就是这两个附属构件的classifier。这样，附属构件也就拥有了自己唯一的坐标。 还有一个关于classifier的典型例子是TestNG, TestNG的主构件是基于Java1.4平台的，而它又提供了一个clas­sifier为jdk5的附属构件。注意，不能直接定义项目的classifier, 因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成。 上述5个元素中，groupId、artifactId、version是必须定义的，packaging是可选的（默认为jar),而classifier是不能直接定义的。 同时，项目构件的文件名是与坐标相对应的，一般的规则为artifactId-version[-classifier].packaging, [-classifier]表示可选。比如上例nexus-indexer的主构件为nexus-indexer-2.0.0.jar,附属构件有nexus-indexer-2.0.0-javadoc.jar。 这里还要强调的一点是，packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件扩展名为jar。 account-email回想在上面提到的背景案例，案例中有一个email模块负责发送账户激活的电子邮件，本节就详细阐述该模块的实现，包括POM配置、主代码和测试代码。由于该背景案例的实现是基于Spring Framework, 因此还会涉及相关的 Spring配置。 account-email的POM···未完待续···]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Maven实战》学习（二）]]></title>
    <url>%2F2018%2F04%2F12%2Fmaven_2%2F</url>
    <content type="text"><![CDATA[Maven使用入门编写POMMaven的核心就是pom.xml。POM(Project Object Model,项目对象模型)定义了项目的基本信息，用于描述项目如何构建，声明项目如何依赖等等。 新建一个hello-world文件夹，打开该文件夹，新建pom.xml,输入如下内容：12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.jgh.hello&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-world&lt;/name&gt;&lt;/project&gt; 代码第一行是XML头，指定了该xml的版本和编码方式。 project是所有pom.xml的根元素，他声明了一些POM相关的命名空间和xsd元素。 modelVersion指定了当前POM模型的版本，对于Maven2和Maven3来说，它只能是4.0.0。 这段代码中最重要的是包含groupId、artifactId和verison三行，这三个元素定义了一个项目的基本坐标，在Maven世界中，任何的jar、pom或者war都是以基于这些基本的坐标来进行区分的。 groupId定义了项目属于哪个组，这些组往往和项目所在的公司或组织存在关联，如果你的公司是mycom,有一个项目为myapp,那么groupId就应该为com.mycom.myapp。 artifactId定义了当前Maven项目在组中的唯一Id。 version指定了Hello World项目的当前版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本，随着项目的发展，verison会不断更新。 name不是必须的，但推荐写上，当在MyEclipse中导入时，这个名字将作为项目名。 编写主代码项目主代码和测试代码不同，主代码会被打包到最终构件中（如jar）,而测试代码只在运行测试时用到，不会被打包。 默认情况下，Maven假设项目主代码位于src/main/java目录，我们遵循Maven的预定，创建该目录，然后在该目录下创建cn/jgh/hello/helloworld/HelloWorld.java,代码如下：12345678910package cn.jgh.hello.helloworld;public class HelloWorld&#123; public String sayHello()&#123; return "Hello Maven"; &#125; public static void main(String[] args)&#123; System.out.print(new HelloWorld().sayHello()); &#125;&#125; 关于该Java代码有两点需要注意，首先，在绝大多数情况下应该把项目主代码放到src/main/java目录下（遵循Maven的约定），而无需额外的配置，Maven会自动搜寻该目录找到项目主代码。其次，包名为cn.jgh.hello.helloworld，这与之前在POM中的定义的groupId和artifactId相吻合。一般来说，项目中的Jave包都应该基于项目的groupId和artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或Java类。 在项目根目录下运行如下命令行：1mvn clean compile clean告诉Maven清理输出目录target/,compile告诉Maven编译项目主代码。首先Maven执行clean任务，删除target/目录。默认情况下，Maven构建的所有输出都在target/目录下，执行compile任务，将项目主代码编译至target/classes目录中（编译好的类为：cn/jgh/hello/helloworld/HelloWorld.class） 编写测试代码为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录中。 Maven项目中，默认的测试代码目录是src/test/java,因此，在编写测试用例之前，应该先创建该目录。 在Java世界中，一般使用JUnit进行单元测试，要使用JUnit,首先需要为Hello World项目添加一个JUnit依赖，修改项目的POM如下代码所示:123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.jgh.hello&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-world&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 代码中添加了dependencies元素，该元素下可包含多个dependency元素以声明项目的依赖。有了JUnit这段声明，Maven就会自动下载junit-4.7.jar。Maven从哪里下载这些Jar呢？在Maven之前，可以去JUnit的官方网站下载分发包，有了Maven，他会自动访问Maven中央仓库，下载需要的文件。我们也可以自己访问该仓库，打开路径junit/junit/4.7/，就可以看到junit-4.7.jar和junit-4.7.pom。 代码中scope为依赖范围，若依赖范围为test，则表示该依赖只对测试有效。换句话说，测试代码中的import Junit代码是没问题的，但是在主代码中用import Junit代码，就会造成编译错误。如果不声明依赖范围，则默认值为compile，表示该依赖对主代码和测试代码均有效。 接下来编写测试类，来验证上面编写的Jave类的sayHello()方法是否能在控制台输出“Hello Maven”。在src/test/java目录下创建文件，其内容如下代码所示：12345678910package cn.jgh.hello.helloworld;import org.junit.Test;public class HelloWorldTest&#123; @Test public void testSayHello()&#123; HelloWorld helloWorld=new HelloWorld(); System.out.println(helloWorld.sayHello()); &#125;&#125; 一个典型的单元测试包含三个步骤： 准备测试类及数据 执行要测试的行为 检查结果 同时，在JUnit4中，需要执行的测试方法都应该以@Test进行标注。 测试用例编写完毕后就可以在项目根目录下调用Maven执行以下命令，进行测试1mvn clean test 命令行输入的是mvn clean test,而maven执行的可不止这两个任务，在执行test之前，它会先自动执行项目的主资源处理、主代码编译、测试资源处理、测试代码编译等工作，这是Maven生命周期的一个特性，关于Maven的生命周期，后面将会看到。 Maven从中央仓库下载了junit4.7.pom和junit4.7.jar这两个文件到本地仓库中（~/.m2/reposity）中，供所有的Maven项目使用。 如果控制台最后输出如下类似代码，则说明测试通过。123456789101112···------------------------------------------------------- T E S T S-------------------------------------------------------Running cn.jgh.hello.helloworld.HelloWorldTestHello MavenTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.047 secResults :Tests run: 1, Failures: 0, Errors: 0, Skipped: 0··· 打包和运行Hello World的POM中没有指定打包类型，使用默认的打包类型jar。简单地在项目根目录下调用以下命令进行打包1mvn clean package 可以看到类似如下结果1234567891011121314151617181920···------------------------------------------------------- T E S T S-------------------------------------------------------Running cn.jgh.hello.helloworld.HelloWorldTestHello MavenTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.048 secResults :Tests run: 1, Failures: 0, Errors: 0, Skipped: 0···[INFO] Building jar: E:\mavenLearn\hello-world\target\hello-world-1.0-SNAPSHOT.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 10.205 s[INFO] Finished at: 2018-04-12T15:00:34+08:00[INFO] ------------------------------------------------------------------------··· 类似地Maven会在打包之前进行编译、测试等操作。打包之后的文件也位于target/输出目录下，文件名为hello-world-1.0-SNAPSHOT.jar，它是根据artifact-version.jar规则进行命名的。如果有需要，就可以复制这个jar文件到其他项目的classpath中从而使用HelloWorld类。 如果要让其他Maven项目直接引用这个jar呢？还需要一个步骤，在项目根目录下执行以下代码1mvn clean install 可以看到类似如下结果123456789101112···[INFO] Installing E:\mavenLearn\hello-world\target\hello-world-1.0-SNAPSHOT.jar tepository\cn\jgh\hello\hello-world\1.0-SNAPSHOT\hello-world-1.0-SNAPSHOT.jar[INFO] Installing E:\mavenLearn\hello-world\pom.xml to C:\Users\Administrator\.m2-world\1.0-SNAPSHOT\hello-world-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 27.854 s[INFO] Finished at: 2018-04-12T15:19:03+08:00[INFO] ------------------------------------------------------------------------··· 同样地，在执行install之前，会执行删除target/,编译，测试和打包等操作。从输出结果中可以看出，install将项目输出的jar包安装到了Maven本地仓库中，可以打开相应的文件夹看到Hello World项目的pom和jar文件。只要将Hello World的构件安装到本地仓库之后，其他的Maven项目就可以使用它。 因为Hello World类是有一个main方法的，所以是可以运行的，但是默认打包成的jar是不能直接运行的，因为带有main方法的信息不会添加到manifest中(打开jar文件的META-INF/MANIFEST.MF文件，将无法看到Main-Class一行)。我们可以手动添加如下代码到jar文件的META-INF/MANIFEST.MF文件中：1Main-Class: cn.jgh.hello.helloworld.HelloWorld 需要注意的是，Main-Class:之后是一个英文状态下的空格 然后，在项目根目录下运行以下代码执行jar文件：1java -jar target\hello-world-1.0-SNAPSHOT.jar 控制台输出Hello Maven,这正是我们想要的。 使用Archetype生成项目骨架离开当前目录另建一个项目，来测试Maven提供的Archetype帮助我们快速勾勒出项目骨架。 在新建的目录下，运行以下代码:1mvn archetype:generate 接下来将看到一段长长的输出，有很多可用的Archetype可供选择。每一个Archetype前面都会对应一个编号，同时命令行将会提示一个默认的编号，其对应的Archetype为maven-archetype-quickstart,直接回车以选择该Archetype,紧接着Maven会提示要输入项目的groupId、artifactId、version、以及包名package。如下输入并确认：12345678910Define value for property &apos;groupId&apos;: cn.jgh.mavenDefine value for property &apos;artifactId&apos;: hello-worldDefine value for property &apos;version&apos; 1.0-SNAPSHOT: :Define value for property &apos;package&apos; cn.jgh.maven: : cn.jgh.maven.helloworldConfirm properties configuration:groupId: cn.jgh.mavenartifactId: hello-worldversion: 1.0-SNAPSHOTpackage: cn.jgh.maven.helloworld Y: : Y Archetype插件将根据我们提供的信息创建项目骨架。在当前目录下，Archetype插件会创建一个名为hello-world（根据我们定义的artifactId）的子目录，从中可以看到项目的基本结构：基本的pom.xml已经被创建，里面包含了必要的信息以及一个junit依赖；主代码目录src/main/java，在该目录下还有一个Java类cn.jgh.maven.helloworld.APP,同时测试代码目录src/test/java也已经被创建好,并且包含一个测试用例cn.jgh.maven.helloworld.APPTest。 Archetype可以帮助我们迅速地构建起项目的骨架，在以后的开发中我们就可以使用此种方法生成骨架，然后在此骨架的基础上开发项目以节省大量时间。 m2eclipse的简单使用导入maven项目 选择菜单项File-&gt;选择Import 在Import对话框中选择Maven4MyEclipse下的Existing Maven Projects，然后单击next按钮 在Impott Maven Projects对话框中单击Browse按钮选择Hello World的根目录（即包含pom.xml文件的那个目录） 单击Finish按钮之后，就会将项目导入到当前的workspace中了 在Package Explore视图中,可以看到主代码目录结构src/main/java和测试代码目录结构src/test/java成了 MyEclipse中的资源目录，当然pom.xml永远在根目录下，还可以看到项目的依赖junit-4.7.jar,其实际位置指向了指向了Maven本地仓库。 创建Maven项目 选择菜单项File-&gt;New-&gt;Other 在弹出的对话框中选择Maven4MyEclipse下的Maven Project,然后单击Next按钮 在弹出的窗口中默认的选项，单击Next按钮 此时会提示我们选择一个ArcheType，这里选择maven-archetype-quickstart插件创建项目，因此这一步骤和上一节使用的Archetype创建项目骨架类似，输入groupId、artifactId、version、package 输入完毕后，单击Finish按钮，Maven项目就创建完成了 运行Maven命令在Maven项目或者pom.xml上右击，在弹出的快捷菜单中选择Run As，就能看到常见的Maven命令。选择想要执行的命令，就能执行相应的构件，同时还能在MyEclipse控制台看到构建输出。 可以看到Run As右边没有我们想要的命令，比如maven clean test,我们可以选择Maven build以自定义Maven运行命令,在弹出对话框的Goals一项中输入我们想要执行的命令，如clean test,设置一下Name,单击Run即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Maven实战》学习（一）]]></title>
    <url>%2F2018%2F04%2F11%2Fmaven_1%2F</url>
    <content type="text"><![CDATA[Maven简介何为Maven？Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 为什么要用Maven？Maven能够帮助我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。 Maven是跨平台的，这意味着无论在Windows、Linux还是Mac上都可以使用相同的命令。 Maven最大化地消除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了插件，我们不需要实现过程，甚至不再需要去实现这些过程中的一些任务。最简单的例子就是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编好测试用例，当我们运行构建的时候，这些测试便会自动运行。 Maven不仅是构建工具，还是一个依赖管理工具和项目信息管理工具。它提供中央仓库，能帮我们自动下载构件。 Maven的安装和配置在Windows上安装Maven检查JDK的安装Maven可以运行在JDK1.4及以上版本。 打开命令行，输入以下命令来检查JDK安装 1echo %JAVA_HOME% 1java -version Maven下载Maven下载地址,Windows下是zip文件，如apache-maven-3.5.3-bin.zip。 本地安装在指定的目录中运行以下命令将安装文件解压到当前目录（如D:\Maven）1D:\Maven&gt;jar xvf &quot;D:\Downloads\apache-maven-3.5.3-bin.zip&quot; 设置环境变量，将Maven安装配置到操作系统中： 右击“计算机”-&gt;“属性”-&gt;“高级系统设置”-&gt;”环境变量”； 在系统变量中新建一个变量，变量名为“M2_HOME”,变量值为Maven的安装目录D:\Maven\apache-maven-3.5.3，单击‘确定’按钮； 在系统变量中找到Path变量，双击Path变量，在变量值末尾添加%M2_HOME%\bin;，（多个值之间用英文分号（;）隔开），单击‘确定’按钮。 值得注意的是Path环境变量。当我们在cmd中执行命令行时，Windows首先会在当前目录中寻找可执行的脚本或文件，如果没找到，Windows会接着遍历环境变量Path中定义的路径。打开一个新的命令行窗口，执行以下命令验证Maven是否安装成功1mvn -v执行以上之后命令出现类似如下结果，则说明安装成功Apache Maven 3.5.3 (3383c37e1f9e9b3bc3df5050c29c8aff9f295297; 2018-02-25T03:49:05+08:00)Maven home: D:\Maven\apache-maven-3.5.3\bin..Java version: 1.8.0_144, vendor: Oracle CorporationJava home: D:\Java\jdk1.8.0_144\jreDefault locale: zh_CN, platform encoding: GBKOS name: “windows 7”, version: “6.1”, arch: “amd64”, family: “windows” 升级Maven只需要把新下载下来的文件解压到文件目录中，然后替换掉系统变量M2_HOME的变量值即可。 在基于UNIX的系统上安装Maven检查JDK的安装打开命令行，输入以下命令来检查JDK安装 1echo %JAVA_HOME% 1java -version Maven下载Maven下载地址,UNIX下是tar.gz文件，如apache-maven-3.5.3-bin.tar.gz。 本地安装在指定的目录中运行以下命令将安装文件解压到当前目录（如D:\Maven）1D:\Maven&gt;tar-xvzf &quot;D:\Downloads\apache-maven-3.5.3-bin.tar.gz&quot; 现在已经创建好了一个Maven安装目录apache-maven-3.5.3，虽然直接使用该目录配置环境后就能使用Maven了，但这里推荐的做法是，在安装目录旁平行地创建一个符号链接，以便日后的升级：1ln-s apache-maven-3.5.3 apache-maven 1ls-l 接下来，设置M2_HOME环境变量指向符号链接apache-maven,并且把Maven安装目录下的bin/文件添加到系统环境变量PATH中1export M2_HOME=/home/juven/bin/apache-maven 1export PATH=$ PATH: $ M2-HOME/bin 运行以下命令检查Maven是否安装成功 mvn -v 安装目录分析M2_HOMEM2_HOME即Maven的安装目录，例如D:\Maven\apache-maven-3.5.3。 bin 该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。 boot 该目录下只有一个文件，对于一般的Maven用户，不用关心该文件 conf 该目录下包含一个重要的文件settings.xml，后面会多次介绍该文件 lib 该目录包含了所有Maven运行的Java类库，用户还可以 LICENSE.txt记录了Maven使用的软件许可证Apache License Version2.0 NOTICE.txt记录了Maven包含的第三方软件 README.txt包含了Maven的简要介绍，以及安装需求和如何安装的简要指令 ~/.m2在命令行窗口中执行mvn help:system（非必须）,然后可以在用户目录中（例如：C:\Users\Administrator）看到生成的.m文件夹，默认情况下，该文件夹下放置了Maven本地仓库.m2/repository。所有的Maven构件都被存储到该仓库中，以方便重用。 maven安装最佳实践设置MAVEN_OPTS环境变量通常设置MAVEN_OPTS的值为-Xms128m -Xmx512m,因为Java默认的最大可用内存往往不能满足Maven运行的需要,容易得到java.lang.OutofMemeoryError,所以一开始就配置是推荐的做法。 关于如何设置环境变量，请参考前面设置M2_HOME环境变量的做法，尽量不要直接修改mvn.bat或者mvn这两个Maven执行脚本文件。因为如果修改了脚本文件，升级Maven时就不得不再次去修改，同理，应该尽可能地不去修改Maven安装目录下的任何文件。 配置用户范围的settings.xml用户可以选择配置M2_HOME/conf/settings,xml或者~/.m2/settings.xml。前者是全局范围的，整台机器上的用户都会受到该配置的影响，而后者是用户范围的，只有当前用户才会受到该配置的影响。 推荐使用用户范围的settings.xml,一方面既不影响其他用户，另一方面升级之后也不用替换新升级文件夹下的settings.xml。 不要使用IDE内嵌的Maven一般情况下，IDE内嵌的Maven通常都比较新，但不一定很稳定，而且往往和命令行使用的Maven不是同一个版本。这里又出现两个潜在的问题：首先，较新版本的Maven存在很多不稳定因素，容易造成一些难以理解的问题；其次，除了IDE，还经常会使用命令行的Maven,如果版本不一致，则容易造成构件行为的不一致。所以，应该在IDE中配置Maven插件，使用与命令行一致的Maven。 在MyEclipse中，单击菜单栏中的Window,选择Preferences,在左边菜单栏中，单击MyEclipse,然后单击Maven4MyEclipse,选择Installation子项，在右边的画板中，能够看到有一个默认的Embedded Maven安装被选中了。单击Add…按钮，然后选择Maven安装目录M2_HOME，添加完毕之后勾选这一外部的Maven]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tools]]></title>
    <url>%2F2018%2F04%2F11%2Ftools%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 PDF阅读器小巧好用的PDF阅读器：SumatraPDF下载 SumatraPDF快捷键 Markdown编辑器所写即所得：MarkdownPad下载 注册码 User： 1Soar360@live.com 授权：1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 高清图库10 个免费的高清图库网站，强烈推荐☞☞☞ lrc歌词下载lrc歌词下载 视频播发器低内存占用、无广告、功能强大又唯美的本地播放器PotPlayer 技术书单如果有人让你推荐编程技术书，请叫他看这个列表 脚本工具老司机开车脚本 一些实用的脚本 网站导航龙轩导航 一个框，全能搜 浏览器插件音乐 SecureCRTSecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。 SecureCRT下载 提取密码：02mc]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>PDF</tag>
        <tag>图库</tag>
        <tag>Markdown</tag>
        <tag>视频播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3344——Forever]]></title>
    <url>%2F2018%2F04%2F09%2Ffriends%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-AODgDVea"), narrow: false, autoplay: true, showlrc: 3, music: { title: "朋友", author: "龙井说唱", url: "http://p6v6hsmcp.bkt.clouddn.com/%E9%BE%99%E4%BA%95%E8%AF%B4%E5%94%B1%20-%20%E6%9C%8B%E5%8F%8B.mp3", pic: "http://p6v6hsmcp.bkt.clouddn.com/timg%20%286%29.jpg", lrc: "http://p6v6hsmcp.bkt.clouddn.com/%E9%BE%99%E4%BA%95%E8%AF%B4%E5%94%B1-%E6%9C%8B%E5%8F%8B.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 人之间的友谊，并非由于说不尽的好处，倒是说不出的要好。 ——钱钟书为什么要引用钱钟书先生说的话呢，因为我不知道该怎么开头。就算是引用了又怎么样呢，我还是不知道写什么。如果让我在写文章和吃屎之间做个选择的话，我会毫不犹豫的选择写文章(&gt;▽&lt;)。写这篇文章是为了感谢3344的兄弟姐妹们对我个人博客的支持和鼓励，也纪念3344的我们在一起九年了。在这里首先谢谢秀梅，许浩和秀才的红包，在我装逼的时候给我捧场，谢谢你们，么么哒。说实在的，这个年龄写这个有点矫情了，但谁在乎呢（道系还是佛系？）。2009年，很荣幸的把我分到了0830班，又阴差阳错的进了3344寝室 ，确认过眼神，我遇到对的人，嗯，这些都是对的人。彦武彦武，我的老大哥，我们认识已经十一年了，本来想送你一首《十一年》呢，但是我忍住了(认真脸)。接下来的五一就是你的大喜日子了，小弟在这里祝你和浏阳百年好合，早生贵子，我还等着当叔叔呢。最后，一首歌送给你们。 var ap = new APlayer({ element: document.getElementById("aplayer-QLKJlRki"), narrow: false, autoplay: false, showlrc: 3, music: { title: "给你们", author: "张宇", url: "http://p6v6hsmcp.bkt.clouddn.com/%E5%BC%A0%E5%AE%87%20-%20%E7%BB%99%E4%BD%A0%E4%BB%AC.mp3", pic: "http://p6v6hsmcp.bkt.clouddn.com/u=3963152680,1514268489&fm=27&gp=0.jpg", lrc: "http://p6v6hsmcp.bkt.clouddn.com/%E5%BC%A0%E5%AE%87-%E7%BB%99%E4%BD%A0%E4%BB%AC.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 东升东升，人生赢家，把大家的秀梅拐走了，我就不谴责你了，因为我估计还排不上队，就留给他们谴责吧，哈哈。说点正事，赶紧和秀梅把证领了，把事办了，大家还都等着喝喜酒呢。壮壮，当爹的人了，大家的表率，在幸福的道路上已经超越了我们一圈，也是我们走向人生幸福道路的领头羊。说这么多，其实是想让你传授一下经验，带领以许浩为代表的单身狗们早日走向人生巅峰。毕竟以你这模样还能娶到嫂子这么漂亮贤惠的姑娘，大概是情圣了吧。说你丑，十一长大不会打我吧。扬飞扬飞，我们的曹老师。自从你当了老师之后，让我对老师有了从新的认识，原来人还可以这么衣冠禽兽。当然了，也谢谢你带我认识了另外一位老师，苍老师，我和她已经好久没联系了，不知道你还能牵上线吗？最后，祝艳彩你俩早点办事。秀才秀才，一个假的印度人。只想告诉你，在广西那边少嫖点娼。你这人渣不如的东西，你对的起你的家人吗？你对的起你自己的良心吗？你自己想想。不是我骂你，你就知道享受她们的肉体，可是你有没有想过你的家人，你未来的女朋友，你简直就是畜生。我不想多说，只想对你说，下次再有这种事发生，请带上我，知道吗？保持联络！孙宽孙宽，我们唯一的研究生。多吃点饭，把自己养胖了，还有赶紧给我找个嫂子，不要搞基。许浩许浩，哥哥。人到中年不得已，保温杯里泡枸杞。多锻炼身体，看你虚的，这几天是不是又病了，还记得你曾经是多么的猛男吗？最近，看你在微信运动里，一天天的占领我的朋友圈，感到压力的同时，也感觉那个猛男要回来了。加油吧哥哥，早日给我找个嫂子。胡胡，同样的人生赢家，曾经那个带我打英雄联盟的小胖子（并不是个子低，只是胖的不明显），现在也已经结婚了，走在了人生幸福的道路上。最后，祝督京老师你俩早生贵子。秀梅秀梅，我们的大妹妹。为什么你和东升在一块了还要单列出来呢，可能是我受了贿赂吧。赶紧和东升把事办了，看好你们哦。小明小明，我们的小妹妹，一个开了挂的人。赶紧给我们找个妹夫，单身这么多年，你不着急，我们还着急呢。不要怕他欺负你，毕竟你哥哥那么多不是。在一块的就不单独列出来了，在这里再一次祝你们百年好合（当然也包括东升和秀梅哈）。]]></content>
      <categories>
        <category>friends</category>
      </categories>
      <tags>
        <tag>friends</tag>
        <tag>friendship</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一碗好喝的鸡汤]]></title>
    <url>%2F2018%2F04%2F06%2Fchicken-soup%2F</url>
    <content type="text"><![CDATA[比三观更重要的是 五官 你无法叫醒一个不回你消息的人但是红包能 不要看别人表面上一帆风顺实际上他们背地里也一帆风顺 有的时候哭也是可以解决问题的只要你长得足够漂亮 你全力做到最好还不如别人随便搞搞 生活不止眼前的苟且还有前任发来的请帖 我妈常跟我说找对象的时候不要光看别人的外表也要看看自己的外表 如果可以的话请好好爱自己因为这个世界上没人会爱你 有的时候你不努力一下还真的不知道什么是绝望 所有的事情都会慢慢慢慢慢慢慢慢慢慢慢慢慢慢慢慢好起来的 我真的不懂为什么我那么穷还能吃那么胖 你们之所以喝鸡汤是因为肉被别人吃了 努力不一定会成功但是不努力一定会很轻松 有人出现在你的生命里就是为了告诉你你真好骗 你以为有钱人他就很快乐吗他们的快乐你都想象不到 喜欢一个人就去表白万一成备胎了呢]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2F2018%2F04%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-gWWrceJC"), narrow: false, autoplay: true, showlrc: 3, music: { title: "Hello", author: "Adele", url: "http://p6v6hsmcp.bkt.clouddn.com/Adele%20-%20Hello.mp3", pic: "http://p6v6hsmcp.bkt.clouddn.com/u=3529119121,1423376518&fm=27&gp=0.jpg", lrc: "http://p6v6hsmcp.bkt.clouddn.com/Adele-Hello.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 欢迎来到我的个人博客 一个好人! 这是我的第一篇博客，说实话我不知道写些什么，但俗话说： 万事开头难，然后中间难，然后结尾难。 嗯，就是这样，激励着我写下这第一篇博客。 5W1H分析why可能是为了装逼吧，也可能是为了记录些什么，我还分不清楚两者的区别。 what写博客 where家里or公司 when空闲的时候 who当然是我了，难道是别人不成 how用电脑写吧，这个好像还挺难的（认真脸） 最后分享一篇最近在知乎上看到的一篇文章，人是怎么废掉的？算是给自己提个醒吧~(≧▽≦)/！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
