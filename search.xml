<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中对File的操作]]></title>
    <url>%2F2018%2F04%2F20%2FFile%2F</url>
    <content type="text"><![CDATA[一直以来对File类中的API不太了解，今天借着对《Java编程思想（第4版）》中第18.1章File类的学习，做一个相对深入的研究。 创建创建目录123456789101112131415161718 /** * 创建目录 * @param as_Path 路径 * @return 创建后的文件对象 * @throws Exception 方法异常 * */public static File uf_CreateDirectory(String as_Path) throws Exception&#123; File file=new File(as_Path); if(file.exists())&#123; if(!file.isDirectory())&#123; throw new Exception("路径存在但不是目录！"); &#125; &#125; //如果文件夹不存在，则会创建，并返回true;如果存在，则不会创建，并返回false file.mkdirs(); return file;&#125; 在这里普及一下mkdirs()和mkdir()的区别： mkdirs()可以建立多级文件夹， mkdir()只会建立一级的文件夹， 如下：1new File("/tmp/one/two/three").mkdirs(); 执行后， 会建立tmp/one/two/three四级目录1new File("/tmp/one/two/three").mkdir(); 则不会建立任何目录， 因为找不到/tmp/one/two目录， 结果返回false 创建文件12345678910111213141516171819202122232425262728293031/** * 创建文件 * @param as_Path 路径 * @param isDelete 如果文件已存在，是否删除 * @return 创建后的文件对象 * @throws Exception 方法异常 */public static File uf_CreateFile(String as_Path,boolean isDelete) throws Exception&#123; File file=new File(as_Path); if(file.exists())&#123; if(isDelete)&#123; //删除文件 file.delete(); file.createNewFile(); &#125; &#125;else&#123; if(as_Path.endsWith(File.separator))&#123; throw new Exception("创建单个文件" +as_Path + "失败，目标文件不能为目录！"); &#125; //判断目标文件所在的目录是否存在 if(file.getParentFile()!=null)&#123; if(!file.getParentFile().exists())&#123; if(!file.getParentFile().mkdirs()) &#123; throw new Exception("创建目标文件所在目录失败！"); &#125; &#125; &#125; file.createNewFile(); &#125; return file;&#125; 在创建文件时，必须保证目标文件不存在，而且父目录存在，否则会创建失败 删除删除目录12345678910111213141516171819202122232425262728/** * 删除目录（包括子目录） * @param as_Path 要删除的目录路径 * @param isIncludeRoot 是否包含路径本身 * @throws Exception 方法异常 */public static void uf_DelTree(String as_Path,boolean isIncludeRoot) throws Exception&#123; File file=new File(as_Path); if(!file.exists())&#123; throw new Exception("要删除的路径不存在！"); &#125; if(!file.isDirectory())&#123; throw new Exception("路径存在，但不是目录！"); &#125; File[] files=file.listFiles(); String fileName; for(File file1:files)&#123; fileName=file1.getName(); if(file1.isDirectory())&#123; FileHelper.uf_DelTree(as_Path+File.separator+fileName, true); &#125;else&#123; file1.delete(); &#125; &#125; if(isIncludeRoot)&#123; file.delete(); &#125;&#125; 在这里普及一下File类中的list()和listFiles()方法的区别： list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组 listFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组 list()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); String[] fileNames=file.list(); for(String fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567build.xmlDocumentation1.javaDocumentation2.javaDocumentation3.javaHelloDate.javaHelloDate1.javaShowProperties.java listFiles()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); File[] fileNames=file.listFiles(); for(File fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567E:\thinkingInJava\Think in Java 4 code\object\build.xmlE:\thinkingInJava\Think in Java 4 code\object\Documentation1.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation2.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation3.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate1.javaE:\thinkingInJava\Think in Java 4 code\object\ShowProperties.java 删除文件123456789101112131415161718/** * 删除文件 * @param as_Path 要删除的文件路径 * @throws Exception 方法异常 */public static void uf_DelFile(String as_Path) throws Exception&#123; File file=new File(as_Path); if(!file.exists())&#123; throw new Exception("要删除的文件不存在！"); &#125; if(as_Path.endsWith(File.separator))&#123; throw new Exception("删除单个文件" +as_Path + "失败，目标文件不能为目录！"); &#125; if(!file.isFile())&#123; throw new Exception("删除单个文件" +as_Path + "失败，目标文件不是文件！"); &#125; file.delete();&#125; 修改复制文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 复制文件 * @param as_SourFile 源文件路径 * @param as_DestFile 目标文件路径 * @param isOvercast 如果目标文件存在是否覆盖 * @throws Exception 方法异常 */public static File uf_CopyFile(String as_SourFile,String as_DestFile,boolean isOvercast) throws Exception&#123; File sourFile=new File(as_SourFile); if(!sourFile.exists())&#123; throw new Exception("复制文件" +as_SourFile + "失败，源文件不存在！"); &#125; if(!sourFile.isFile())&#123; throw new Exception("复制文件" +as_SourFile + "失败，源文件不是文件！"); &#125; File destFile=new File(as_DestFile); if(destFile.exists())&#123; if(!destFile.isFile())&#123; throw new Exception("复制文件" +as_SourFile + "失败，目标路径"+as_DestFile+"存在,但不是文件！"); &#125; if(!isOvercast)&#123; return destFile; &#125; &#125; FileInputStream fileInputStream=null; FileOutputStream fileOutputStream=null; try &#123; fileInputStream=new FileInputStream(sourFile); fileOutputStream=new FileOutputStream(destFile); byte[] buf=new byte[1024]; int len=0; while((len=fileInputStream.read(buf))!=-1)&#123; fileOutputStream.write(buf, 0, len); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception(e); &#125;finally&#123; if(fileInputStream!=null)&#123; fileInputStream.close(); &#125; if(fileOutputStream!=null)&#123; fileOutputStream.close(); &#125; &#125; return destFile;&#125; 复制目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 目录复制(含子目录) * @param as_sPath 源路径 * @param as_dPath 目标路径 * @param ab_IsIncludeRoot 是否包含源路径本身 * @throws Exception 方法异常 */public static void uf_CopyTree(String as_sPath, String as_dPath, boolean ab_IsIncludeRoot) throws Exception&#123; File lo_sFile = new File(as_sPath); if (!lo_sFile.exists()) throw new Exception("源路径并不存在。"); if (!lo_sFile.isDirectory()) throw new Exception("源路径并非目录。"); File lo_dFile = new File(as_dPath); if (!lo_dFile.exists())&#123; lo_dFile.mkdirs(); &#125; if (!lo_dFile.isDirectory()) throw new Exception("目标路径并非目录。"); File lo_NewFile, lo_File; String ls_Name; if (ab_IsIncludeRoot) &#123; ls_Name = lo_sFile.getName(); lo_NewFile = new File(as_dPath +File.separator + ls_Name); if (!lo_NewFile.exists()) &#123; lo_NewFile.mkdir(); &#125; else &#123; if (!lo_NewFile.isDirectory()) throw new Exception("目标路径存在但并非目录。"); &#125; FileHelper.uf_CopyTree(as_sPath, as_dPath + File.separator + ls_Name, false); &#125; else &#123; File[] lo_Files = lo_sFile.listFiles(); for (int ii = 0; ii &lt; lo_Files.length; ii++) &#123; lo_File = lo_Files[ii]; ls_Name = lo_File.getName(); if (lo_File.isDirectory()) &#123; lo_NewFile = new File(as_dPath + File.separator + ls_Name); if (!lo_NewFile.exists()) &#123; lo_NewFile.mkdir(); &#125; else &#123; if (!lo_NewFile.isDirectory()) throw new Exception("目标路径存在但并非目录。"); &#125; FileHelper.uf_CopyTree(as_sPath + File.separator + ls_Name, as_dPath + File.separator + ls_Name, false); &#125; else &#123; FileHelper.uf_CopyFile(as_sPath + File.separator + ls_Name, as_dPath + File.separator + ls_Name, true); &#125; &#125; &#125;&#125; 移动文件123456789101112131415/** * 移动文件 * @param as_sFile 源文件路径 * @param as_dFile 目标文件路径 * @param ab_IsOvercast 目标文件存在是否覆盖 * @return 移动后的File对象 * @throws Exception 方法异常 */public static File uf_MoveFile(String as_sFile, String as_dFile, boolean ab_IsOvercast) throws Exception&#123; File lo_sFile = new File(as_sFile); File lo_dFile = FileHelper.uf_CopyFile(as_sFile, as_dFile, ab_IsOvercast); lo_sFile.delete(); return lo_dFile;&#125; 查看首先，再普及一下File类中的list()和listFiles()方法的区别： list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组 listFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组 list()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); String[] fileNames=file.list(); for(String fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567build.xmlDocumentation1.javaDocumentation2.javaDocumentation3.javaHelloDate.javaHelloDate1.javaShowProperties.java listFiles()1234567public static void main(String[] args) throws Exception &#123; File file=new File("E:/thinkingInJava/Think in Java 4 code/object"); File[] fileNames=file.listFiles(); for(File fileName:fileNames)&#123; System.out.println(fileName); &#125; &#125; 结果如下：1234567E:\thinkingInJava\Think in Java 4 code\object\build.xmlE:\thinkingInJava\Think in Java 4 code\object\Documentation1.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation2.javaE:\thinkingInJava\Think in Java 4 code\object\Documentation3.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate.javaE:\thinkingInJava\Think in Java 4 code\object\HelloDate1.javaE:\thinkingInJava\Think in Java 4 code\object\ShowProperties.java 目录列表器对符合条件的文件进行筛选12345678910111213141516171819202122232425262728/** * 筛选符合条件的文件 * @param as_sFile 目录文件 * @param reg 要筛选的文件正则表达式 * @return 符合条件的文件集合 * @throws Exception */public static String[] uf_ListFile(String as_sFile,final String reg)throws Exception&#123; File path = new File(as_sFile); if (!path.exists()) throw new Exception("源路径并不存在。"); if (!path.isDirectory()) throw new Exception("源路径并非目录。"); String[] list; if(reg==null||"".equals(reg)) list = path.list(); else //匿名内部类 list = path.list(new FilenameFilter() &#123; private Pattern pattern = Pattern.compile(reg); public boolean accept(File dir, String name) &#123; return pattern.matcher(name).matches(); &#125; &#125;); //按字母顺序排序 Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); return list;&#125; 查看源码]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>File</tag>
        <tag>Java I/O系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单点登录]]></title>
    <url>%2F2018%2F04%2F19%2FSingleSignOn%2F</url>
    <content type="text"><![CDATA[发现一篇讲解单点登录非常好的文章，直接上网址:单点登录原理与简单实现]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中MD5加密和JavaScript中MD5加密]]></title>
    <url>%2F2018%2F04%2F19%2Fmd5%2F</url>
    <content type="text"><![CDATA[Java中MD5加密废话不多说，直接上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.security.MessageDigest;import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.File;/** * &lt;p&gt; * Title: Md5Helper类 * &lt;/p&gt; * &lt;p&gt; * Description: 获取一个文件或字节数组的MD5信息摘要 */public final class Md5Helper&#123; /** * 类禁止外部实例化 */ private Md5Helper() &#123; //donone &#125; /** * 获取一个字节数组的MD5信息摘要 * * @param as_Info * 原始信息 * @return MD5信息摘要 * @throws java.lang.IllegalArgumentException * 如果参数无效 * @throws java.lang.Exception * 包含其它任何异常 */ public static byte[] uf_Md5(byte[] as_Info) throws IllegalArgumentException, Exception &#123; if ((as_Info == null) || (as_Info.length == 0)) &#123; throw new IllegalArgumentException("无效参数"); &#125; MessageDigest alga = java.security.MessageDigest.getInstance("MD5"); alga.update(as_Info); return alga.digest(); &#125; /** * 加密 * 字节数组转换为16进制显示 * @param info 字节数组 * @return 16进制显示字符串 */ public static String uf_byte2hex(byte[] info) &#123; String hs = ""; String stmp = ""; for (int n = 0; n &lt; info.length; n++) &#123; stmp = (java.lang.Integer.toHexString(info[n] &amp; 0XFF)); if (stmp.length() == 1) &#123; hs = hs + "0" + stmp; &#125; else &#123; hs = hs + stmp; &#125; &#125; return hs; &#125; /** *主方法测试 */ public static void main(String[] args) throws IllegalArgumentException, Exception &#123; System.out.println(uf_byte2hex(uf_Md5("value".getBytes())));//2063c1608d6e0baf80249c42e2be5804 System.out.println(uf_byte2hex(uf_Md5("111111".getBytes())));//96e79218965eb72c92a549dd5a330112 &#125;&#125; JavaScript中MD5加密废话不多说，直接上代码1234&lt;script src="yourUrl/md5.min.js"&gt;&lt;/script&gt; 或者： &lt;script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"&gt;&lt;/script&gt; 示例：12var hash = md5("value"); // 2063c1608d6e0baf80249c42e2be5804 var hash = md5("111111"); // 96e79218965eb72c92a549dd5a330112 参考： http://www.bootcdn.cn/blueimp-md5/ https://github.com/blueimp/JavaScript-MD5]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>js</tag>
        <tag>加密技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中取得链接参数某参数的值]]></title>
    <url>%2F2018%2F04%2F19%2FJavaScript_1%2F</url>
    <content type="text"><![CDATA[不多说，直接上代码12345678910111213function getLinkValue(paraName) &#123; var strHref = window.document.location.href; var intPos = strHref.indexOf("?"); var strRight = strHref.substr(intPos + 1); var arrTmp = strRight.split("&amp;"); for ( var i = 0; i &lt; arrTmp.length; i=i+1) &#123; var arrTemp = arrTmp[i].split("="); if (arrTemp[0].toUpperCase() == paraName.toUpperCase()) return arrTemp[1]; &#125; return ""; &#125; 用法如下：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt; New Document &lt;/TITLE&gt; &lt;META NAME="Generator" CONTENT="EditPlus"&gt; &lt;META NAME="Author" CONTENT=""&gt; &lt;META NAME="Keywords" CONTENT=""&gt; &lt;META NAME="Description" CONTENT=""&gt; &lt;script type="text/javascript"&gt; window.onload=function()&#123; alert(getLinkValue('jhg')); &#125; function getLinkValue(paraName) &#123; var strHref = window.document.location.href; var intPos = strHref.indexOf("?"); var strRight = strHref.substr(intPos + 1); var arrTmp = strRight.split("&amp;"); for ( var i = 0; i &lt; arrTmp.length; i=i+1) &#123; var arrTemp = arrTmp[i].split("="); if (arrTemp[0].toUpperCase() == paraName.toUpperCase()) return arrTemp[1]; &#125; return ""; &#125; &lt;/script&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;/BODY&gt;&lt;/HTML&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Maven实战》学习（三）]]></title>
    <url>%2F2018%2F04%2F13%2Fmaven_3%2F</url>
    <content type="text"><![CDATA[背景案例接下里的Maven学习，将引入一个真实的案例来进行学习，该案例的目的还是帮助我们理解Maven的概念， 以及展示大部分Maven项目需要面对和处理的一些问题。 简单的注册服务注册互联网账户是日常生活中再熟悉不过的一件事悄 ，作为一个用户，注册账户的时候往往需要做以下事情： 提供一个未被使用的账号ID 提供一个未被使用的Email地址 提供一个任意的显示名称 设置安全密码，并重复输入以确认 输入验证码 前往邮箱查收激活链接并单击激活账号 登录 写这些的主要目的是让读者清楚地了解这个背景案例 即账户注册服务，它的需求是什么？基于这样的一个需求 ，我们会怎样设计这个小型的系统。 需求阐述下面从软件工程的视角来分析一下该服务的需求： 需求用例 注册账户主耍场景： 1.用户访问注册页面2.系统生成验证码图片3.用户输入想要的ID、Email地址，想要的显示名称、密码、确认密码4.用户输入验证码5.用户提交注册请求6.系统检查验证码7.系统检查ID是否已经被注册，Email是否已经被注册，密码和确认密码是否一致8.系统保存未激活的账户信息9.系统生成激活链接，井发送至用户邮箱10.用户打开邮箱，访问激活链接11.系统解析激活链接，激活相关账户12.用户使用ID和密码登录 扩展场景 4a: 用户无法看清验证玛，请求重新生成 1.跳转到步骤2 6a: 系统检测到用户输入的验证码错误 1.系统提示验证码错误2.跳转到步骤2 7a: 系统检测到ID已被注册，或者Email已被注册，或者密码和确认密码不一致 1.系统提示相关错误信息2.跳转到步骤2 该用例的角色只有两个：用户和系统。“主要场景”描述了用户如何与系统一步一步地交互，并且成功完成注册; “扩展场景”则描述了一些中途发生意外的情形，比如用户输错验证码的时候，系统就需要从新生成验证码，用户也需要重新输入验证码。 简要设计接口从需求用例中可以看到，系统对外的接口包括生成验证码图片、处理注册请求、激活账户以及处理登录等。 模块结构 cn.jgh.account.service: 系统的核心，它封装了所有下层细节，对外暴露简单的接口。 cn.jgh.account.web: 顾名思义该模块包含所有与web相关的内容，包括可能的JSP、Servlet、web.xml等，它直接依赖于cn.jgh.account.service模块，使用其提供的服务。 cn.jgh.maven.account.persist: 处理账户信息的持久化，包括增、删、改、查等。根据实现，可以基于数据库或者文件。 cn.jgh.account.captcha: 处理验证码的key生成、图片生成以及验证等。这里需要第三方的类库来帮助实现这些功能。 cn.jgh.account.email: 处理邮件服务的配置、激活邮件的编写和发送。 坐标和依赖正如前面介绍的， Maven的一大功能是管理项目依赖。 为了能自动化地解析任何一个Java构件，Maven就必须将它们唯一标识，这就依赖管理的底层基础——坐标。 何为Maven坐标？Maven的世界中拥有数量非常巨大的构件，也就是平时用的一些jar、war等构件。在Maven为这些构件引人坐标概念之前，我们无法使用任何一种方式来唯一标识所有这些构件。 因此，当需要用到SpringFramework依赖的时候，大家会去SpringFramework网站寻找；当需要用到log4j依赖的时候,大家又会去Apache网站寻找。又因为各个项目的网站风格迥异，大量的时间花费在了搜索、浏览网页等工作上面。 没有统一的规范、统一的法则，该工作就无法自动化。Maven定义了这样一组规则：世界上任何一个构件都可以使用Maven坐标唯一标识，Maven坐标的元素包括groupID、artifactId、version、packaging、classifier。现在，只要我们提供正确的坐标元素，Maven就能找到对应的构件。Maven是从哪里下载构件的呢？答案其实很简单，Maven内置了一个中央仓库的地址,该中央仓库包含了世界上大部分流行的开源项目构件， Maven会在需要的时候去那里下载。 坐标详解一组Maven坐标是通过一些元素定义的，它们是groupId、artifactId、version、packaging、classifier。看下面的代码：1234&lt;groupId&gt;org.sonatype.nexus&lt;/groupId&gt; &lt;artifactId&gt;nexus-indexer&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; groupId：定义当前Maven项目隶属的实际项目。 首先，Maven项目和实际项目不一定是一对一的关系。 比如 SpringFramework这一实际项目，其对应的Maven项目会有很多，如spring-core、spring-context等。 这是由于Maven中模块的概念，因此，一个实际项目往往会被划分成很多模块。其次，groupId不应该对应项目隶属的组织或公司。原因很简单，一个组织下会有很多实际项目，如果groupId只定义到组织级别,而后面我们会看到artifactId只能定义Maven项目（模块），那么实际项目这个层将难以定义。 最后，groupId的表示方式与Java 包名的表示方式类似，通常与域名反向一一对应。 上面的代码中，groupId为org.sonatype.nexus，org.sonatype表示Sonatype公司建立的一个非盈利性组织，nexus表示Nexus这一实际项目，该groupId与域名 nexus.sonatype.org对应。 artifactId：该元素定义实际项目中的一个Maven项目（模块），推荐的做法是使用实际项目名称作为artifactId的前缀。比如上面的代码中的artifactId是nexus-indexer,使用了实际项目名nexus作为前缀，这样做的好处是方便寻找实际构件。在默认情况下，Ma­ven生成的构件，其文件名会以artifactId作为开头，如nexus-indexer-2.0.0.jar, 使用实际项目名称作为前缀之后，就能方便从一个lib文件夹中找到某个项目的一组构件。 考虑有5个项目，每个项目都有一个core模块，如果没有前缀，我们会行到很多core-1.2.jar这样的文件，加上实际项目名前缀之后， 便能很容易区分foo-core-1.2.jar、bar-core-1.2.jar…… version：该元素定义Maven项目当前所处的版本，如上面的代码中，nexus-indexer的版本是2.0.0。需要注意的是，Maven定义了一套完成的版本规范，以及快照(SNAPSHOT)的概念。 后面会详细讨论版本管理内容。 packaging：该元素定义Maven项目的打包方式。 首先，打包方式通常与所生成构件的文件扩展名对应，如上面的代码中packaging为jar。 最终的文件名为nexus-indexer-2.0.0.jar,而使用war打包方式的Maven项目，最终生成的构件会有一个.war文件，不过这不是绝对的。 其次，打包方式会影响到构建的生命周期，比如jar打包和war打包会使用不同的命令。最后，当不定义packaging的时候，Maven会使用默认值jar。 ­classifier：该元素用来帮助定义构建输出的一些附属构件。附属构件与主构件对应，如上例中的主构件是nexus-indexer-2.0.0.jar, 该项目可能还会通过使用一些插件生成如nexus-indexer-2.0.0-javadoc.jar、 nexus-indexer-2.0.0-sources.jar这样一些附属构件，其包含了Java文档和源代码。这时候，javadoc和sources就是这两个附属构件的classifier。这样，附属构件也就拥有了自己唯一的坐标。 还有一个关于classifier的典型例子是TestNG, TestNG的主构件是基于Java1.4平台的，而它又提供了一个clas­sifier为jdk5的附属构件。注意，不能直接定义项目的classifier, 因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成。 上述5个元素中，groupId、artifactId、version是必须定义的，packaging是可选的（默认为jar),而classifier是不能直接定义的。 同时，项目构件的文件名是与坐标相对应的，一般的规则为artifactId-version[-classifier].packaging, [-classifier]表示可选。比如上例nexus-indexer的主构件为nexus-indexer-2.0.0.jar,附属构件有nexus-indexer-2.0.0-javadoc.jar。 这里还要强调的一点是，packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件扩展名为jar。 account-email回想在上面提到的背景案例，案例中有一个email模块负责发送账户激活的电子邮件，本节就详细阐述该模块的实现，包括POM配置、主代码和测试代码。由于该背景案例的实现是基于Spring Framework, 因此还会涉及相关的 Spring配置。 account-email的POM···未完待续···]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Maven实战》学习（二）]]></title>
    <url>%2F2018%2F04%2F12%2Fmaven_2%2F</url>
    <content type="text"><![CDATA[Maven使用入门编写POMMaven的核心就是pom.xml。POM(Project Object Model,项目对象模型)定义了项目的基本信息，用于描述项目如何构建，声明项目如何依赖等等。 新建一个hello-world文件夹，打开该文件夹，新建pom.xml,输入如下内容：12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.jgh.hello&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-world&lt;/name&gt;&lt;/project&gt; 代码第一行是XML头，指定了该xml的版本和编码方式。 project是所有pom.xml的根元素，他声明了一些POM相关的命名空间和xsd元素。 modelVersion指定了当前POM模型的版本，对于Maven2和Maven3来说，它只能是4.0.0。 这段代码中最重要的是包含groupId、artifactId和verison三行，这三个元素定义了一个项目的基本坐标，在Maven世界中，任何的jar、pom或者war都是以基于这些基本的坐标来进行区分的。 groupId定义了项目属于哪个组，这些组往往和项目所在的公司或组织存在关联，如果你的公司是mycom,有一个项目为myapp,那么groupId就应该为com.mycom.myapp。 artifactId定义了当前Maven项目在组中的唯一Id。 version指定了Hello World项目的当前版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本，随着项目的发展，verison会不断更新。 name不是必须的，但推荐写上，当在MyEclipse中导入时，这个名字将作为项目名。 编写主代码项目主代码和测试代码不同，主代码会被打包到最终构件中（如jar）,而测试代码只在运行测试时用到，不会被打包。 默认情况下，Maven假设项目主代码位于src/main/java目录，我们遵循Maven的预定，创建该目录，然后在该目录下创建cn/jgh/hello/helloworld/HelloWorld.java,代码如下：12345678910package cn.jgh.hello.helloworld;public class HelloWorld&#123; public String sayHello()&#123; return "Hello Maven"; &#125; public static void main(String[] args)&#123; System.out.print(new HelloWorld().sayHello()); &#125;&#125; 关于该Java代码有两点需要注意，首先，在绝大多数情况下应该把项目主代码放到src/main/java目录下（遵循Maven的约定），而无需额外的配置，Maven会自动搜寻该目录找到项目主代码。其次，包名为cn.jgh.hello.helloworld，这与之前在POM中的定义的groupId和artifactId相吻合。一般来说，项目中的Jave包都应该基于项目的groupId和artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或Java类。 在项目根目录下运行如下命令行：1mvn clean compile clean告诉Maven清理输出目录target/,compile告诉Maven编译项目主代码。首先Maven执行clean任务，删除target/目录。默认情况下，Maven构建的所有输出都在target/目录下，执行compile任务，将项目主代码编译至target/classes目录中（编译好的类为：cn/jgh/hello/helloworld/HelloWorld.class） 编写测试代码为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录中。 Maven项目中，默认的测试代码目录是src/test/java,因此，在编写测试用例之前，应该先创建该目录。 在Java世界中，一般使用JUnit进行单元测试，要使用JUnit,首先需要为Hello World项目添加一个JUnit依赖，修改项目的POM如下代码所示:123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.jgh.hello&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-world&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 代码中添加了dependencies元素，该元素下可包含多个dependency元素以声明项目的依赖。有了JUnit这段声明，Maven就会自动下载junit-4.7.jar。Maven从哪里下载这些Jar呢？在Maven之前，可以去JUnit的官方网站下载分发包，有了Maven，他会自动访问Maven中央仓库，下载需要的文件。我们也可以自己访问该仓库，打开路径junit/junit/4.7/，就可以看到junit-4.7.jar和junit-4.7.pom。 代码中scope为依赖范围，若依赖范围为test，则表示该依赖只对测试有效。换句话说，测试代码中的import Junit代码是没问题的，但是在主代码中用import Junit代码，就会造成编译错误。如果不声明依赖范围，则默认值为compile，表示该依赖对主代码和测试代码均有效。 接下来编写测试类，来验证上面编写的Jave类的sayHello()方法是否能在控制台输出“Hello Maven”。在src/test/java目录下创建文件，其内容如下代码所示：12345678910package cn.jgh.hello.helloworld;import org.junit.Test;public class HelloWorldTest&#123; @Test public void testSayHello()&#123; HelloWorld helloWorld=new HelloWorld(); System.out.println(helloWorld.sayHello()); &#125;&#125; 一个典型的单元测试包含三个步骤： 准备测试类及数据 执行要测试的行为 检查结果 同时，在JUnit4中，需要执行的测试方法都应该以@Test进行标注。 测试用例编写完毕后就可以在项目根目录下调用Maven执行以下命令，进行测试1mvn clean test 命令行输入的是mvn clean test,而maven执行的可不止这两个任务，在执行test之前，它会先自动执行项目的主资源处理、主代码编译、测试资源处理、测试代码编译等工作，这是Maven生命周期的一个特性，关于Maven的生命周期，后面将会看到。 Maven从中央仓库下载了junit4.7.pom和junit4.7.jar这两个文件到本地仓库中（~/.m2/reposity）中，供所有的Maven项目使用。 如果控制台最后输出如下类似代码，则说明测试通过。123456789101112···------------------------------------------------------- T E S T S-------------------------------------------------------Running cn.jgh.hello.helloworld.HelloWorldTestHello MavenTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.047 secResults :Tests run: 1, Failures: 0, Errors: 0, Skipped: 0··· 打包和运行Hello World的POM中没有指定打包类型，使用默认的打包类型jar。简单地在项目根目录下调用以下命令进行打包1mvn clean package 可以看到类似如下结果1234567891011121314151617181920···------------------------------------------------------- T E S T S-------------------------------------------------------Running cn.jgh.hello.helloworld.HelloWorldTestHello MavenTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.048 secResults :Tests run: 1, Failures: 0, Errors: 0, Skipped: 0···[INFO] Building jar: E:\mavenLearn\hello-world\target\hello-world-1.0-SNAPSHOT.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 10.205 s[INFO] Finished at: 2018-04-12T15:00:34+08:00[INFO] ------------------------------------------------------------------------··· 类似地Maven会在打包之前进行编译、测试等操作。打包之后的文件也位于target/输出目录下，文件名为hello-world-1.0-SNAPSHOT.jar，它是根据artifact-version.jar规则进行命名的。如果有需要，就可以复制这个jar文件到其他项目的classpath中从而使用HelloWorld类。 如果要让其他Maven项目直接引用这个jar呢？还需要一个步骤，在项目根目录下执行以下代码1mvn clean install 可以看到类似如下结果123456789101112···[INFO] Installing E:\mavenLearn\hello-world\target\hello-world-1.0-SNAPSHOT.jar tepository\cn\jgh\hello\hello-world\1.0-SNAPSHOT\hello-world-1.0-SNAPSHOT.jar[INFO] Installing E:\mavenLearn\hello-world\pom.xml to C:\Users\Administrator\.m2-world\1.0-SNAPSHOT\hello-world-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 27.854 s[INFO] Finished at: 2018-04-12T15:19:03+08:00[INFO] ------------------------------------------------------------------------··· 同样地，在执行install之前，会执行删除target/,编译，测试和打包等操作。从输出结果中可以看出，install将项目输出的jar包安装到了Maven本地仓库中，可以打开相应的文件夹看到Hello World项目的pom和jar文件。只要将Hello World的构件安装到本地仓库之后，其他的Maven项目就可以使用它。 因为Hello World类是有一个main方法的，所以是可以运行的，但是默认打包成的jar是不能直接运行的，因为带有main方法的信息不会添加到manifest中(打开jar文件的META-INF/MANIFEST.MF文件，将无法看到Main-Class一行)。我们可以手动添加如下代码到jar文件的META-INF/MANIFEST.MF文件中：1Main-Class: cn.jgh.hello.helloworld.HelloWorld 需要注意的是，Main-Class:之后是一个英文状态下的空格 然后，在项目根目录下运行以下代码执行jar文件：1java -jar target\hello-world-1.0-SNAPSHOT.jar 控制台输出Hello Maven,这正是我们想要的。 使用Archetype生成项目骨架离开当前目录另建一个项目，来测试Maven提供的Archetype帮助我们快速勾勒出项目骨架。 在新建的目录下，运行以下代码:1mvn archetype:generate 接下来将看到一段长长的输出，有很多可用的Archetype可供选择。每一个Archetype前面都会对应一个编号，同时命令行将会提示一个默认的编号，其对应的Archetype为maven-archetype-quickstart,直接回车以选择该Archetype,紧接着Maven会提示要输入项目的groupId、artifactId、version、以及包名package。如下输入并确认：12345678910Define value for property &apos;groupId&apos;: cn.jgh.mavenDefine value for property &apos;artifactId&apos;: hello-worldDefine value for property &apos;version&apos; 1.0-SNAPSHOT: :Define value for property &apos;package&apos; cn.jgh.maven: : cn.jgh.maven.helloworldConfirm properties configuration:groupId: cn.jgh.mavenartifactId: hello-worldversion: 1.0-SNAPSHOTpackage: cn.jgh.maven.helloworld Y: : Y Archetype插件将根据我们提供的信息创建项目骨架。在当前目录下，Archetype插件会创建一个名为hello-world（根据我们定义的artifactId）的子目录，从中可以看到项目的基本结构：基本的pom.xml已经被创建，里面包含了必要的信息以及一个junit依赖；主代码目录src/main/java，在该目录下还有一个Java类cn.jgh.maven.helloworld.APP,同时测试代码目录src/test/java也已经被创建好,并且包含一个测试用例cn.jgh.maven.helloworld.APPTest。 Archetype可以帮助我们迅速地构建起项目的骨架，在以后的开发中我们就可以使用此种方法生成骨架，然后在此骨架的基础上开发项目以节省大量时间。 m2eclipse的简单使用导入maven项目 选择菜单项File-&gt;选择Import 在Import对话框中选择Maven4MyEclipse下的Existing Maven Projects，然后单击next按钮 在Impott Maven Projects对话框中单击Browse按钮选择Hello World的根目录（即包含pom.xml文件的那个目录） 单击Finish按钮之后，就会将项目导入到当前的workspace中了 在Package Explore视图中,可以看到主代码目录结构src/main/java和测试代码目录结构src/test/java成了 MyEclipse中的资源目录，当然pom.xml永远在根目录下，还可以看到项目的依赖junit-4.7.jar,其实际位置指向了指向了Maven本地仓库。 创建Maven项目 选择菜单项File-&gt;New-&gt;Other 在弹出的对话框中选择Maven4MyEclipse下的Maven Project,然后单击Next按钮 在弹出的窗口中默认的选项，单击Next按钮 此时会提示我们选择一个ArcheType，这里选择maven-archetype-quickstart插件创建项目，因此这一步骤和上一节使用的Archetype创建项目骨架类似，输入groupId、artifactId、version、package 输入完毕后，单击Finish按钮，Maven项目就创建完成了 运行Maven命令在Maven项目或者pom.xml上右击，在弹出的快捷菜单中选择Run As，就能看到常见的Maven命令。选择想要执行的命令，就能执行相应的构件，同时还能在MyEclipse控制台看到构建输出。 可以看到Run As右边没有我们想要的命令，比如maven clean test,我们可以选择Maven build以自定义Maven运行命令,在弹出对话框的Goals一项中输入我们想要执行的命令，如clean test,设置一下Name,单击Run即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Maven实战》学习（一）]]></title>
    <url>%2F2018%2F04%2F11%2Fmaven_1%2F</url>
    <content type="text"><![CDATA[Maven简介何为Maven？Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 为什么要用Maven？Maven能够帮助我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。 Maven是跨平台的，这意味着无论在Windows、Linux还是Mac上都可以使用相同的命令。 Maven最大化地消除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了插件，我们不需要实现过程，甚至不再需要去实现这些过程中的一些任务。最简单的例子就是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编好测试用例，当我们运行构建的时候，这些测试便会自动运行。 Maven不仅是构建工具，还是一个依赖管理工具和项目信息管理工具。它提供中央仓库，能帮我们自动下载构件。 Maven的安装和配置在Windows上安装Maven检查JDK的安装Maven可以运行在JDK1.4及以上版本。 打开命令行，输入以下命令来检查JDK安装 1echo %JAVA_HOME% 1java -version Maven下载Maven下载地址,Windows下是zip文件，如apache-maven-3.5.3-bin.zip。 本地安装在指定的目录中运行以下命令将安装文件解压到当前目录（如D:\Maven）1D:\Maven&gt;jar xvf &quot;D:\Downloads\apache-maven-3.5.3-bin.zip&quot; 设置环境变量，将Maven安装配置到操作系统中： 右击“计算机”-&gt;“属性”-&gt;“高级系统设置”-&gt;”环境变量”； 在系统变量中新建一个变量，变量名为“M2_HOME”,变量值为Maven的安装目录D:\Maven\apache-maven-3.5.3，单击‘确定’按钮； 在系统变量中找到Path变量，双击Path变量，在变量值末尾添加%M2_HOME%\bin;，（多个值之间用英文分号（;）隔开），单击‘确定’按钮。 值得注意的是Path环境变量。当我们在cmd中执行命令行时，Windows首先会在当前目录中寻找可执行的脚本或文件，如果没找到，Windows会接着遍历环境变量Path中定义的路径。打开一个新的命令行窗口，执行以下命令验证Maven是否安装成功1mvn -v执行以上之后命令出现类似如下结果，则说明安装成功Apache Maven 3.5.3 (3383c37e1f9e9b3bc3df5050c29c8aff9f295297; 2018-02-25T03:49:05+08:00)Maven home: D:\Maven\apache-maven-3.5.3\bin..Java version: 1.8.0_144, vendor: Oracle CorporationJava home: D:\Java\jdk1.8.0_144\jreDefault locale: zh_CN, platform encoding: GBKOS name: “windows 7”, version: “6.1”, arch: “amd64”, family: “windows” 升级Maven只需要把新下载下来的文件解压到文件目录中，然后替换掉系统变量M2_HOME的变量值即可。 在基于UNIX的系统上安装Maven检查JDK的安装打开命令行，输入以下命令来检查JDK安装 1echo %JAVA_HOME% 1java -version Maven下载Maven下载地址,UNIX下是tar.gz文件，如apache-maven-3.5.3-bin.tar.gz。 本地安装在指定的目录中运行以下命令将安装文件解压到当前目录（如D:\Maven）1D:\Maven&gt;tar-xvzf &quot;D:\Downloads\apache-maven-3.5.3-bin.tar.gz&quot; 现在已经创建好了一个Maven安装目录apache-maven-3.5.3，虽然直接使用该目录配置环境后就能使用Maven了，但这里推荐的做法是，在安装目录旁平行地创建一个符号链接，以便日后的升级：1ln-s apache-maven-3.5.3 apache-maven 1ls-l 接下来，设置M2_HOME环境变量指向符号链接apache-maven,并且把Maven安装目录下的bin/文件添加到系统环境变量PATH中1export M2_HOME=/home/juven/bin/apache-maven 1export PATH=$ PATH: $ M2-HOME/bin 运行以下命令检查Maven是否安装成功 mvn -v 安装目录分析M2_HOMEM2_HOME即Maven的安装目录，例如D:\Maven\apache-maven-3.5.3。 bin 该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。 boot 该目录下只有一个文件，对于一般的Maven用户，不用关心该文件 conf 该目录下包含一个重要的文件settings.xml，后面会多次介绍该文件 lib 该目录包含了所有Maven运行的Java类库，用户还可以 LICENSE.txt记录了Maven使用的软件许可证Apache License Version2.0 NOTICE.txt记录了Maven包含的第三方软件 README.txt包含了Maven的简要介绍，以及安装需求和如何安装的简要指令 ~/.m2在命令行窗口中执行mvn help:system（非必须）,然后可以在用户目录中（例如：C:\Users\Administrator）看到生成的.m文件夹，默认情况下，该文件夹下放置了Maven本地仓库.m2/repository。所有的Maven构件都被存储到该仓库中，以方便重用。 maven安装最佳实践设置MAVEN_OPTS环境变量通常设置MAVEN_OPTS的值为-Xms128m -Xmx512m,因为Java默认的最大可用内存往往不能满足Maven运行的需要,容易得到java.lang.OutofMemeoryError,所以一开始就配置是推荐的做法。 关于如何设置环境变量，请参考前面设置M2_HOME环境变量的做法，尽量不要直接修改mvn.bat或者mvn这两个Maven执行脚本文件。因为如果修改了脚本文件，升级Maven时就不得不再次去修改，同理，应该尽可能地不去修改Maven安装目录下的任何文件。 配置用户范围的settings.xml用户可以选择配置M2_HOME/conf/settings,xml或者~/.m2/settings.xml。前者是全局范围的，整台机器上的用户都会受到该配置的影响，而后者是用户范围的，只有当前用户才会受到该配置的影响。 推荐使用用户范围的settings.xml,一方面既不影响其他用户，另一方面升级之后也不用替换新升级文件夹下的settings.xml。 不要使用IDE内嵌的Maven一般情况下，IDE内嵌的Maven通常都比较新，但不一定很稳定，而且往往和命令行使用的Maven不是同一个版本。这里又出现两个潜在的问题：首先，较新版本的Maven存在很多不稳定因素，容易造成一些难以理解的问题；其次，除了IDE，还经常会使用命令行的Maven,如果版本不一致，则容易造成构件行为的不一致。所以，应该在IDE中配置Maven插件，使用与命令行一致的Maven。 在MyEclipse中，单击菜单栏中的Window,选择Preferences,在左边菜单栏中，单击MyEclipse,然后单击Maven4MyEclipse,选择Installation子项，在右边的画板中，能够看到有一个默认的Embedded Maven安装被选中了。单击Add…按钮，然后选择Maven安装目录M2_HOME，添加完毕之后勾选这一外部的Maven]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tools]]></title>
    <url>%2F2018%2F04%2F11%2Ftools%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 PDF阅读器小巧好用的PDF阅读器：SumatraPDF下载 SumatraPDF快捷键 Markdown编辑器所写即所得：MarkdownPad下载 注册码 User： 1Soar360@live.com 授权：1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 高清图库10 个免费的高清图库网站，强烈推荐☞☞☞ lrc歌词下载lrc歌词下载 视频播发器低内存占用、无广告、功能强大又唯美的本地播放器PotPlayer 技术书单如果有人让你推荐编程技术书，请叫他看这个列表 脚本工具老司机开车脚本 一些实用的脚本 网站导航龙轩导航 一个框，全能搜 浏览器插件音乐]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>PDF</tag>
        <tag>图库</tag>
        <tag>Markdown</tag>
        <tag>视频播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3344——Forever]]></title>
    <url>%2F2018%2F04%2F09%2Ffriends%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-xmeMEdqq"), narrow: false, autoplay: true, showlrc: 3, music: { title: "朋友", author: "龙井说唱", url: "http://p6v6hsmcp.bkt.clouddn.com/%E9%BE%99%E4%BA%95%E8%AF%B4%E5%94%B1%20-%20%E6%9C%8B%E5%8F%8B.mp3", pic: "http://p6v6hsmcp.bkt.clouddn.com/timg%20%286%29.jpg", lrc: "http://p6v6hsmcp.bkt.clouddn.com/%E9%BE%99%E4%BA%95%E8%AF%B4%E5%94%B1-%E6%9C%8B%E5%8F%8B.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 人之间的友谊，并非由于说不尽的好处，倒是说不出的要好。 ——钱钟书为什么要引用钱钟书先生说的话呢，因为我不知道该怎么开头。就算是引用了又怎么样呢，我还是不知道写什么。如果让我在写文章和吃屎之间做个选择的话，我会毫不犹豫的选择写文章(&gt;▽&lt;)。写这篇文章是为了感谢3344的兄弟姐妹们对我个人博客的支持和鼓励，也纪念3344的我们在一起九年了。在这里首先谢谢秀梅，许浩和秀才的红包，在我装逼的时候给我捧场，谢谢你们，么么哒。说实在的，这个年龄写这个有点矫情了，但谁在乎呢（道系还是佛系？）。2009年，很荣幸的把我分到了0830班，又阴差阳错的进了3344寝室 ，确认过眼神，我遇到对的人，嗯，这些都是对的人。彦武彦武，我的老大哥，我们认识已经十一年了，本来想送你一首《十一年》呢，但是我忍住了(认真脸)。接下来的五一就是你的大喜日子了，小弟在这里祝你和浏阳百年好合，早生贵子，我还等着当叔叔呢。最后，一首歌送给你们。 var ap = new APlayer({ element: document.getElementById("aplayer-RRGjBZLL"), narrow: false, autoplay: false, showlrc: 3, music: { title: "给你们", author: "张宇", url: "http://p6v6hsmcp.bkt.clouddn.com/%E5%BC%A0%E5%AE%87%20-%20%E7%BB%99%E4%BD%A0%E4%BB%AC.mp3", pic: "http://p6v6hsmcp.bkt.clouddn.com/u=3963152680,1514268489&fm=27&gp=0.jpg", lrc: "http://p6v6hsmcp.bkt.clouddn.com/%E5%BC%A0%E5%AE%87-%E7%BB%99%E4%BD%A0%E4%BB%AC.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 东升东升，人生赢家，把大家的秀梅拐走了，我就不谴责你了，因为我估计还排不上队，就留给他们谴责吧，哈哈。说点正事，赶紧和秀梅把证领了，把事办了，大家还都等着喝喜酒呢。壮壮，当爹的人了，大家的表率，在幸福的道路上已经超越了我们一圈，也是我们走向人生幸福道路的领头羊。说这么多，其实是想让你传授一下经验，带领以许浩为代表的单身狗们早日走向人生巅峰。毕竟以你这模样还能娶到嫂子这么漂亮贤惠的姑娘，大概是情圣了吧。说你丑，十一长大不会打我吧。扬飞扬飞，我们的曹老师。自从你当了老师之后，让我对老师有了从新的认识，原来人还可以这么衣冠禽兽。当然了，也谢谢你带我认识了另外一位老师，苍老师，我和她已经好久没联系了，不知道你还能牵上线吗？最后，祝艳彩你俩早点办事。秀才秀才，一个假的印度人。只想告诉你，在广西那边少嫖点娼。你这人渣不如的东西，你对的起你的家人吗？你对的起你自己的良心吗？你自己想想。不是我骂你，你就知道享受她们的肉体，可是你有没有想过你的家人，你未来的女朋友，你简直就是畜生。我不想多说，只想对你说，下次再有这种事发生，请带上我，知道吗？保持联络！孙宽孙宽，我们唯一的研究生。多吃点饭，把自己养胖了，还有赶紧给我找个嫂子，不要搞基。许浩许浩，哥哥。人到中年不得已，保温杯里泡枸杞。多锻炼身体，看你虚的，这几天是不是又病了，还记得你曾经是多么的猛男吗？最近，看你在微信运动里，一天天的占领我的朋友圈，感到压力的同时，也感觉那个猛男要回来了。加油吧哥哥，早日给我找个嫂子。胡胡，同样的人生赢家，曾经那个带我打英雄联盟的小胖子（并不是个子低，只是胖的不明显），现在也已经结婚了，走在了人生幸福的道路上。最后，祝督京老师你俩早生贵子。秀梅秀梅，我们的大妹妹。为什么你和东升在一块了还要单列出来呢，可能是我受了贿赂吧。赶紧和东升把事办了，看好你们哦。小明小明，我们的小妹妹，一个开了挂的人。赶紧给我们找个妹夫，单身这么多年，你不着急，我们还着急呢。不要怕他欺负你，毕竟你哥哥那么多不是。在一块的就不单独列出来了，在这里再一次祝你们百年好合（当然也包括东升和秀梅哈）。]]></content>
      <categories>
        <category>friends</category>
      </categories>
      <tags>
        <tag>friends</tag>
        <tag>friendship</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一碗好喝的鸡汤]]></title>
    <url>%2F2018%2F04%2F06%2Fchicken-soup%2F</url>
    <content type="text"><![CDATA[比三观更重要的是 五官 你无法叫醒一个不回你消息的人但是红包能 不要看别人表面上一帆风顺实际上他们背地里也一帆风顺 有的时候哭也是可以解决问题的只要你长得足够漂亮 你全力做到最好还不如别人随便搞搞 生活不止眼前的苟且还有前任发来的请帖 我妈常跟我说找对象的时候不要光看别人的外表也要看看自己的外表 如果可以的话请好好爱自己因为这个世界上没人会爱你 有的时候你不努力一下还真的不知道什么是绝望 所有的事情都会慢慢慢慢慢慢慢慢慢慢慢慢慢慢慢慢好起来的 我真的不懂为什么我那么穷还能吃那么胖 你们之所以喝鸡汤是因为肉被别人吃了 努力不一定会成功但是不努力一定会很轻松 有人出现在你的生命里就是为了告诉你你真好骗 你以为有钱人他就很快乐吗他们的快乐你都想象不到 喜欢一个人就去表白万一成备胎了呢]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2F2018%2F04%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-XWqaRaQf"), narrow: false, autoplay: true, showlrc: 3, music: { title: "Hello", author: "Adele", url: "http://p6v6hsmcp.bkt.clouddn.com/Adele%20-%20Hello.mp3", pic: "http://p6v6hsmcp.bkt.clouddn.com/u=3529119121,1423376518&fm=27&gp=0.jpg", lrc: "http://p6v6hsmcp.bkt.clouddn.com/Adele-Hello.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 欢迎来到我的个人博客 一个好人! 这是我的第一篇博客，说实话我不知道写些什么，但俗话说： 万事开头难，然后中间难，然后结尾难。 嗯，就是这样，激励着我写下这第一篇博客。 5W1H分析why可能是为了装逼吧，也可能是为了记录些什么，我还分不清楚两者的区别。 what写博客 where家里or公司 when空闲的时候 who当然是我了，难道是别人不成 how用电脑写吧，这个好像还挺难的（认真脸） 最后分享一篇最近在知乎上看到的一篇文章，人是怎么废掉的？算是给自己提个醒吧~(≧▽≦)/！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
